#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TangoLib

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "TangoLib_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class TangoLib.TngAIControllerInterface
// 0x0000 (0x0028 - 0x0028)
class ITngAIControllerInterface final : public IInterface
{
public:
	void AddCombatTargets(class AActor* Actor);
	void ClearPathFindFilter();
	void NotifySmartLinkReached(class ATngNavLinkProxy* NavLink, const struct FVector& Destination);
	void RemoteDriveToLocation(const struct FVector& Destination, float MaxSpeedRate);
	void RemoveCombatTargets(class AActor* Actor);
	void SetPathFindFilter(TSubclassOf<class UNavigationQueryFilter> NewFilter);
	void SetSlowDownAtGoal(bool NewFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAIControllerInterface">();
	}
	static class ITngAIControllerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITngAIControllerInterface>();
	}
};
static_assert(alignof(ITngAIControllerInterface) == 0x000008, "Wrong alignment on ITngAIControllerInterface");
static_assert(sizeof(ITngAIControllerInterface) == 0x000028, "Wrong size on ITngAIControllerInterface");

// Class TangoLib.TngInventoryComponent
// 0x0068 (0x0118 - 0x00B0)
class UTngInventoryComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnShouldNewItem;                                   // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShouldDeleteItem;                                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShouldAddItemCount;                              // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShouldRemoveItemCount;                           // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPostChangeItemCount;                             // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTngInventoryItem>              InventoryList;                                     // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 K2_AddItem(class AActor* Receiver, TSubclassOf<class UTngItemObject> ItemClass, int32 Count, bool IsFake);
	static int32 K2_AddItemList(class AActor* Receiver, TArray<struct FTngInventoryItem>& ItemList, bool IsRemove);
	static int32 K2_GetInventoryCount(class AActor* Receiver);
	static int32 K2_GetInventoryCountFromTag(class AActor* Receiver, class FName CheckTag);
	static int32 K2_GetItemCountFromClass(class AActor* Receiver, TSubclassOf<class UTngItemObject> ItemClass, bool CheckInherit);
	static int32 K2_GetItemCountFromTag(class AActor* Receiver, class FName CheckTag);
	static void K2_TransferInventory(class AActor* Sender, class AActor* Receiver);
	static int32 K2_TransferItem(class AActor* Sender, class AActor* Receiver, TSubclassOf<class UTngItemObject> ItemClass, int32 Count);

	int32 AddItem(TSubclassOf<class UTngItemObject> ItemClass, int32 Count, bool IsFake);
	int32 AddItemList(TArray<struct FTngInventoryItem>& ItemList, bool IsRemove);
	void Blueprint_PostChangeItemCount(TSubclassOf<class UTngItemObject> ItemClass, int32 NewCount, int32 OldCount);
	struct FTngInventoryItem GetInventoryFromClass(TSubclassOf<class UTngItemObject> ItemClass, int32 GetIndex, bool CheckInherit);
	struct FTngInventoryItem GetInventoryFromIndex(int32 GetIndex);
	struct FTngInventoryItem GetInventoryFromTag(class FName CheckTag, int32 GetIndex);
	TArray<struct FTngInventoryItem> GetInventoryListFromClass(TSubclassOf<class UTngItemObject> ItemClass, bool CheckInherit);
	TArray<struct FTngInventoryItem> GetInventoryListFromTag(class FName CheckTag);
	int32 RemoveAllItem(TSubclassOf<class UTngItemObject> ItemClass);
	int32 RemoveItem(TSubclassOf<class UTngItemObject> ItemClass, int32 Count);
	void SetInventoryReturnFlag(bool ReturnBool);
	void SetInventoryReturnNumber(int32 ReturnInt);
	int32 SetItem(TSubclassOf<class UTngItemObject> ItemClass, int32 Count);
	int32 TransferAllItem(class AActor* Receiver, TSubclassOf<class UTngItemObject> ItemClass);
	void TransferInventory(class AActor* Receiver);
	int32 TransferItem(class AActor* Receiver, TSubclassOf<class UTngItemObject> ItemClass, int32 Count);

	int32 Blueprint_ShouldAddItemCount(TSubclassOf<class UTngItemObject> ItemClass, int32 Count) const;
	bool Blueprint_ShouldDeleteItem(TSubclassOf<class UTngItemObject> ItemClass) const;
	bool Blueprint_ShouldNewItem(TSubclassOf<class UTngItemObject> ItemClass) const;
	int32 Blueprint_ShouldRemoveItemCount(TSubclassOf<class UTngItemObject> ItemClass, int32 Count) const;
	int32 GetInventoryCount() const;
	int32 GetInventoryCountFromTag(class FName CheckTag) const;
	const TArray<struct FTngInventoryItem> GetInventoryListAll() const;
	int32 GetItemCount() const;
	int32 GetItemCountFromClass(TSubclassOf<class UTngItemObject> ItemClass, bool CheckInherit) const;
	int32 GetItemCountFromTag(class FName CheckTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngInventoryComponent">();
	}
	static class UTngInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngInventoryComponent>();
	}
};
static_assert(alignof(UTngInventoryComponent) == 0x000008, "Wrong alignment on UTngInventoryComponent");
static_assert(sizeof(UTngInventoryComponent) == 0x000118, "Wrong size on UTngInventoryComponent");
static_assert(offsetof(UTngInventoryComponent, OnShouldNewItem) == 0x0000B0, "Member 'UTngInventoryComponent::OnShouldNewItem' has a wrong offset!");
static_assert(offsetof(UTngInventoryComponent, OnShouldDeleteItem) == 0x0000C0, "Member 'UTngInventoryComponent::OnShouldDeleteItem' has a wrong offset!");
static_assert(offsetof(UTngInventoryComponent, OnShouldAddItemCount) == 0x0000D0, "Member 'UTngInventoryComponent::OnShouldAddItemCount' has a wrong offset!");
static_assert(offsetof(UTngInventoryComponent, OnShouldRemoveItemCount) == 0x0000E0, "Member 'UTngInventoryComponent::OnShouldRemoveItemCount' has a wrong offset!");
static_assert(offsetof(UTngInventoryComponent, OnPostChangeItemCount) == 0x0000F0, "Member 'UTngInventoryComponent::OnPostChangeItemCount' has a wrong offset!");
static_assert(offsetof(UTngInventoryComponent, InventoryList) == 0x000100, "Member 'UTngInventoryComponent::InventoryList' has a wrong offset!");

// Class TangoLib.TngEquipAdvanceParamBase
// 0x0000 (0x0028 - 0x0028)
class UTngEquipAdvanceParamBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngEquipAdvanceParamBase">();
	}
	static class UTngEquipAdvanceParamBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngEquipAdvanceParamBase>();
	}
};
static_assert(alignof(UTngEquipAdvanceParamBase) == 0x000008, "Wrong alignment on UTngEquipAdvanceParamBase");
static_assert(sizeof(UTngEquipAdvanceParamBase) == 0x000028, "Wrong size on UTngEquipAdvanceParamBase");

// Class TangoLib.TngDynamicBlackboardComponent
// 0x0020 (0x00D0 - 0x00B0)
class UTngDynamicBlackboardComponent final : public UActorComponent
{
public:
	TArray<TSubclassOf<class UTngBlackboardData>> DefaultList;                                       // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UTngBlackboardData*>             DataList;                                          // 0x00C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void SetValueAsBool(const class FName& KeyName, bool SetValue);
	void SetValueAsClass(const class FName& KeyName, class UClass* SetValue);
	void SetValueAsEnum(const class FName& KeyName, uint8 SetValue);
	void SetValueAsFloat(const class FName& KeyName, float SetValue);
	void SetValueAsInt(const class FName& KeyName, int32 SetValue);
	void SetValueAsName(const class FName& KeyName, class FName SetValue);
	void SetValueAsObject(const class FName& KeyName, class UObject* SetValue);
	void SetValueAsRotator(const class FName& KeyName, const struct FRotator& SetValue);
	void SetValueAsString(const class FName& KeyName, const class FString& SetValue);
	void SetValueAsVector(const class FName& KeyName, const struct FVector& SetValue);

	bool CheckValueAsBool(const class FName& KeyName) const;
	bool CheckValueAsClass(const class FName& KeyName) const;
	bool CheckValueAsEnum(const class FName& KeyName) const;
	bool CheckValueAsFloat(const class FName& KeyName) const;
	bool CheckValueAsInt(const class FName& KeyName) const;
	bool CheckValueAsName(const class FName& KeyName) const;
	bool CheckValueAsObject(const class FName& KeyName) const;
	bool CheckValueAsRotator(const class FName& KeyName) const;
	bool CheckValueAsString(const class FName& KeyName) const;
	bool CheckValueAsVector(const class FName& KeyName) const;
	bool GetValueAsBool(const class FName& KeyName) const;
	class UClass* GetValueAsClass(const class FName& KeyName) const;
	uint8 GetValueAsEnum(const class FName& KeyName) const;
	float GetValueAsFloat(const class FName& KeyName) const;
	int32 GetValueAsInt(const class FName& KeyName) const;
	class FName GetValueAsName(const class FName& KeyName) const;
	class UObject* GetValueAsObject(const class FName& KeyName) const;
	struct FRotator GetValueAsRotator(const class FName& KeyName) const;
	class FString GetValueAsString(const class FName& KeyName) const;
	struct FVector GetValueAsVector(const class FName& KeyName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngDynamicBlackboardComponent">();
	}
	static class UTngDynamicBlackboardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngDynamicBlackboardComponent>();
	}
};
static_assert(alignof(UTngDynamicBlackboardComponent) == 0x000008, "Wrong alignment on UTngDynamicBlackboardComponent");
static_assert(sizeof(UTngDynamicBlackboardComponent) == 0x0000D0, "Wrong size on UTngDynamicBlackboardComponent");
static_assert(offsetof(UTngDynamicBlackboardComponent, DefaultList) == 0x0000B0, "Member 'UTngDynamicBlackboardComponent::DefaultList' has a wrong offset!");
static_assert(offsetof(UTngDynamicBlackboardComponent, DataList) == 0x0000C0, "Member 'UTngDynamicBlackboardComponent::DataList' has a wrong offset!");

// Class TangoLib.TngAbilityFunction
// 0x0000 (0x0028 - 0x0028)
class UTngAbilityFunction final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAbilityFunction">();
	}
	static class UTngAbilityFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAbilityFunction>();
	}
};
static_assert(alignof(UTngAbilityFunction) == 0x000008, "Wrong alignment on UTngAbilityFunction");
static_assert(sizeof(UTngAbilityFunction) == 0x000028, "Wrong size on UTngAbilityFunction");

// Class TangoLib.TngDynamicDelegateComponent
// 0x0050 (0x0100 - 0x00B0)
class UTngDynamicDelegateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x50];                                      // 0x00B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BindActorDelegateFromItem(class AActor* TargetActor, const class FName DelegateName, const TDelegate<void(class AActor* DelegateActor, class FName DelegateName, class UObject* AdvancedData)>& FunctionItem);
	static bool CallActorDelegate(class AActor* TargetActor, const class FName DelegateName, class UObject* AdvancedData);
	static void UnbindActorDelegateFromItem(class AActor* TargetActor, const class FName DelegateName, const TDelegate<void(class AActor* DelegateActor, class FName DelegateName, class UObject* AdvancedData)>& FunctionItem);

	void BindDelegateFromItem(const class FName DelegateName, const TDelegate<void(class AActor* DelegateActor, class FName DelegateName, class UObject* AdvancedData)>& FunctionItem);
	bool CallDelegate(const class FName DelegateName, class UObject* AdvancedData);
	void UnbindDelegateFromItem(const class FName DelegateName, const TDelegate<void(class AActor* DelegateActor, class FName DelegateName, class UObject* AdvancedData)>& FunctionItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngDynamicDelegateComponent">();
	}
	static class UTngDynamicDelegateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngDynamicDelegateComponent>();
	}
};
static_assert(alignof(UTngDynamicDelegateComponent) == 0x000008, "Wrong alignment on UTngDynamicDelegateComponent");
static_assert(sizeof(UTngDynamicDelegateComponent) == 0x000100, "Wrong size on UTngDynamicDelegateComponent");

// Class TangoLib.TngAbilityInterface
// 0x0000 (0x0028 - 0x0028)
class ITngAbilityInterface final : public IInterface
{
public:
	struct FGameplayTagContainer Blueprint_GetAbilityListForReceive(class UObject* Sender);
	bool Blueprint_InvokeAbility(class UObject* Sender, class UObject* Receiver, const struct FGameplayTag& InvokeTag, class UObject* AdvanceParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAbilityInterface">();
	}
	static class ITngAbilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITngAbilityInterface>();
	}
};
static_assert(alignof(ITngAbilityInterface) == 0x000008, "Wrong alignment on ITngAbilityInterface");
static_assert(sizeof(ITngAbilityInterface) == 0x000028, "Wrong size on ITngAbilityInterface");

// Class TangoLib.TngEquipRelevantInterface
// 0x0000 (0x0028 - 0x0028)
class ITngEquipRelevantInterface final : public IInterface
{
public:
	bool BlueprintNative_BeginAttack();
	bool BlueprintNative_ChangeAttackMode(int32 AttackModeNo);
	bool BlueprintNative_ChargeAttack();
	bool BlueprintNative_Drop();
	bool BlueprintNative_EndAttack();
	bool BlueprintNative_Equip(class AActor* ToActor, class FName SocketName);
	void BlueprintNative_GetActionTags(class AActor* SendActor, struct FGameplayTagContainer* GetTags);
	void BlueprintNative_GetConditionTags(class AActor* SendActor, struct FGameplayTagContainer* GetTags);
	bool BlueprintNative_ReloadAttack();
	bool BlueprintNative_SendActionTag(class AActor* SendActor, const struct FGameplayTag& SendTag);
	bool BlueprintNative_SetAmmoInfinite(bool NewInfinite);
	bool BlueprintNative_SetPrecisionLevel(float NewPrecisionLevel);
	bool BlueprintNative_SetVisible(bool NewVisible);
	bool BlueprintNative_Unequip();

	bool BlueprintNative_GetCondition(int32 AttackModeNo, struct FTngEquipCondition* Condition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngEquipRelevantInterface">();
	}
	static class ITngEquipRelevantInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITngEquipRelevantInterface>();
	}
};
static_assert(alignof(ITngEquipRelevantInterface) == 0x000008, "Wrong alignment on ITngEquipRelevantInterface");
static_assert(sizeof(ITngEquipRelevantInterface) == 0x000028, "Wrong size on ITngEquipRelevantInterface");

// Class TangoLib.TngStateItem
// 0x0028 (0x0050 - 0x0028)
class UTngStateItem : public UObject
{
public:
	class FName                                   StateName;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Priority;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckSamePriority;                                // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35[0x1B];                                      // 0x0035(0x001B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Blueprint_BeginState(class FName PrevState);
	bool Blueprint_CheckIntercept(class FName State);
	void Blueprint_EndState(class FName NextState);
	void Blueprint_InitState();
	void Blueprint_UpdateState(float DeltaTime);
	class FName GetCurrentStateName(class FName SlotName);
	class AActor* GetOwner();
	class AActor* GetOwnerActorClass(TSubclassOf<class AActor> ClassType);
	class UTngStateCoordinateComponent* GetOwnerComponent();
	class UActorComponent* GetOwnerComponentClass(TSubclassOf<class UActorComponent> ClassType);
	void SetFinish(bool Flag);
	void SetFinishAndNextState(class FName Name_0);
	void SetPassive(bool Flag);
	void SetRemove(bool Flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngStateItem">();
	}
	static class UTngStateItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngStateItem>();
	}
};
static_assert(alignof(UTngStateItem) == 0x000008, "Wrong alignment on UTngStateItem");
static_assert(sizeof(UTngStateItem) == 0x000050, "Wrong size on UTngStateItem");
static_assert(offsetof(UTngStateItem, StateName) == 0x000028, "Member 'UTngStateItem::StateName' has a wrong offset!");
static_assert(offsetof(UTngStateItem, Priority) == 0x000030, "Member 'UTngStateItem::Priority' has a wrong offset!");
static_assert(offsetof(UTngStateItem, bCheckSamePriority) == 0x000034, "Member 'UTngStateItem::bCheckSamePriority' has a wrong offset!");

// Class TangoLib.TngAIPerceptionComponent
// 0x0058 (0x01E8 - 0x0190)
class UTngAIPerceptionComponent : public UAIPerceptionComponent
{
public:
	uint8                                         Pad_190[0x8];                                      // 0x0190(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FTngDamageStimulus>        DamageStimuli;                                     // 0x0198(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void ClearDamageStimulus();

	void FindDamageStimulus(int32 ID, struct FTngDamageStimulus* DamageStimulus, bool* Succeeded) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAIPerceptionComponent">();
	}
	static class UTngAIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAIPerceptionComponent>();
	}
};
static_assert(alignof(UTngAIPerceptionComponent) == 0x000008, "Wrong alignment on UTngAIPerceptionComponent");
static_assert(sizeof(UTngAIPerceptionComponent) == 0x0001E8, "Wrong size on UTngAIPerceptionComponent");
static_assert(offsetof(UTngAIPerceptionComponent, DamageStimuli) == 0x000198, "Member 'UTngAIPerceptionComponent::DamageStimuli' has a wrong offset!");

// Class TangoLib.TngEffectActor
// 0x0008 (0x0230 - 0x0228)
class ATngEffectActor : public AActor
{
public:
	class UTngEffectComponent*                    EffectComponent;                                   // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DestroyEffect();
	bool IsActiveEffect();
	void StartEffect(class UTngEffectAsset* EffectAsset, int32 ParticleSortPriority);
	void StopEffect();

	class UTngEffectComponent* GetEffectComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngEffectActor">();
	}
	static class ATngEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATngEffectActor>();
	}
};
static_assert(alignof(ATngEffectActor) == 0x000008, "Wrong alignment on ATngEffectActor");
static_assert(sizeof(ATngEffectActor) == 0x000230, "Wrong size on ATngEffectActor");
static_assert(offsetof(ATngEffectActor, EffectComponent) == 0x000228, "Member 'ATngEffectActor::EffectComponent' has a wrong offset!");

// Class TangoLib.TngGameSystem
// 0x0010 (0x0038 - 0x0028)
class UTngGameSystem : public UObject
{
public:
	bool                                          bAllowPausedUpdate;                                // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0xF];                                       // 0x0029(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Blueprint_BeginPlay();
	void Blueprint_DisplayDebug(class UCanvas* Canvas);
	void Blueprint_Initialization();
	void Blueprint_LevelChanged(const class FString& LevelName);
	void Blueprint_PostInitialization();
	void Blueprint_PostUpdate(float DeltaSeconds);
	void Blueprint_PreUpdate(float DeltaSeconds);
	void Blueprint_PreWorldInitialization();
	void Blueprint_Shutdown();

	class UTngGameInstance* GetOwnerGameInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngGameSystem">();
	}
	static class UTngGameSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngGameSystem>();
	}
};
static_assert(alignof(UTngGameSystem) == 0x000008, "Wrong alignment on UTngGameSystem");
static_assert(sizeof(UTngGameSystem) == 0x000038, "Wrong size on UTngGameSystem");
static_assert(offsetof(UTngGameSystem, bAllowPausedUpdate) == 0x000028, "Member 'UTngGameSystem::bAllowPausedUpdate' has a wrong offset!");

// Class TangoLib.TngSaveLoadSystem
// 0x01B0 (0x01E8 - 0x0038)
class UTngSaveLoadSystem final : public UTngGameSystem
{
public:
	uint8                                         Pad_38[0x1B0];                                     // 0x0038(0x01B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void LoadActorProperties(class AActor* Actor, bool CheckTag);
	static void SaveActorProperties(class AActor* Actor, bool CheckTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngSaveLoadSystem">();
	}
	static class UTngSaveLoadSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngSaveLoadSystem>();
	}
};
static_assert(alignof(UTngSaveLoadSystem) == 0x000008, "Wrong alignment on UTngSaveLoadSystem");
static_assert(sizeof(UTngSaveLoadSystem) == 0x0001E8, "Wrong size on UTngSaveLoadSystem");

// Class TangoLib.TngAbilityComponent
// 0x0000 (0x00B0 - 0x00B0)
class UTngAbilityComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAbilityComponent">();
	}
	static class UTngAbilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAbilityComponent>();
	}
};
static_assert(alignof(UTngAbilityComponent) == 0x000008, "Wrong alignment on UTngAbilityComponent");
static_assert(sizeof(UTngAbilityComponent) == 0x0000B0, "Wrong size on UTngAbilityComponent");

// Class TangoLib.TngEffectAsset
// 0x0028 (0x0058 - 0x0030)
class UTngEffectAsset final : public UDataAsset
{
public:
	struct FTngEffectUnit                         Effect;                                            // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UParticleSystemComponent> ParticleComponent;                                 // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAkComponent>            PlayingAkComponent;                                // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayingID;                                         // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartEffect(class USceneComponent* AttachComponent, bool bFollow, const class FName& AttachName, int32 ParticleSortPriority);
	void StartEffectAtTransform(class UObject* WorldContextObject, const struct FTransform& Transform, int32 ParticleSortPriority);
	void StartEffectToAttach(class USceneComponent* AttachComponent, const class FName& AttachName, const struct FTransform& Offset, int32 ParticleSortPriority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngEffectAsset">();
	}
	static class UTngEffectAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngEffectAsset>();
	}
};
static_assert(alignof(UTngEffectAsset) == 0x000008, "Wrong alignment on UTngEffectAsset");
static_assert(sizeof(UTngEffectAsset) == 0x000058, "Wrong size on UTngEffectAsset");
static_assert(offsetof(UTngEffectAsset, Effect) == 0x000030, "Member 'UTngEffectAsset::Effect' has a wrong offset!");
static_assert(offsetof(UTngEffectAsset, ParticleComponent) == 0x000040, "Member 'UTngEffectAsset::ParticleComponent' has a wrong offset!");
static_assert(offsetof(UTngEffectAsset, PlayingAkComponent) == 0x000048, "Member 'UTngEffectAsset::PlayingAkComponent' has a wrong offset!");
static_assert(offsetof(UTngEffectAsset, PlayingID) == 0x000050, "Member 'UTngEffectAsset::PlayingID' has a wrong offset!");

// Class TangoLib.TngActorFunction
// 0x0000 (0x0028 - 0x0028)
class UTngActorFunction final : public UBlueprintFunctionLibrary
{
public:
	static void GetActorFeetLocation(const class AActor* TargetActor, struct FVector* FeetLocation);
	static const struct FVector GetAIInvalidLocation();
	static struct FRotator GetLocalRotation(const struct FVector& OriginLocation, const struct FRotator& OriginDirection, const struct FVector& TargetLocation);
	static struct FRotator GetLocalRotationActorToActor(const class AActor* OriginActor, const class AActor* TargetActor);
	static class AActor* GetNearActor(const class AActor* TargetActor, const TArray<class AActor*>& ActorList);
	static void MoveTeleportCharacter(class AActor* TargetActor, const struct FVector& SetVec);
	static void PointTeleportCharacter(class AActor* TargetActor, const struct FVector& SetPoint);
	static void RotationTeleportCharacter(class AActor* TargetActor, const struct FRotator& SetRotation);
	static void SetShowOnlyActors(class USceneCaptureComponent* Component, const TArray<class AActor*>& SetActors);
	static bool TngAttachToName(class AActor* ParentActor, class AActor* ChildActor, class FName ParentAttachName, class FName ChildAttachName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
	static bool TngCheckRenderInWindow(class AActor* Actor, const struct FVector& Location, bool CheckTrace);
	static float TngGetActorLength(const class AActor* ActorA, const class AActor* ActorB);
	static void TngGetActorsInActorOwningLevel(class AActor* Actor, TArray<class AActor*>* OutActors);
	static void TngGetActorsInLevel(class ULevelStreamingDynamic* Level, TArray<class AActor*>* OutActors);
	static float TngGetLastRenderTime(class AActor* Actor);
	static struct FTransform TngGetTransformInActor(class AActor* Actor, class FName Name_0, ERelativeTransformSpace Space);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngActorFunction">();
	}
	static class UTngActorFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngActorFunction>();
	}
};
static_assert(alignof(UTngActorFunction) == 0x000008, "Wrong alignment on UTngActorFunction");
static_assert(sizeof(UTngActorFunction) == 0x000028, "Wrong size on UTngActorFunction");

// Class TangoLib.TngGameState
// 0x0000 (0x0298 - 0x0298)
class ATngGameState final : public AGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngGameState">();
	}
	static class ATngGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATngGameState>();
	}
};
static_assert(alignof(ATngGameState) == 0x000008, "Wrong alignment on ATngGameState");
static_assert(sizeof(ATngGameState) == 0x000298, "Wrong size on ATngGameState");

// Class TangoLib.TngEnvQueryTest_TraceIgnorable
// 0x00F0 (0x02E8 - 0x01F8)
class UTngEnvQueryTest_TraceIgnorable final : public UEnvQueryTest
{
public:
	struct FEnvTraceData                          TraceData;                                         // 0x01F8(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               TraceFromContext;                                  // 0x0228(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ItemHeightOffset;                                  // 0x0260(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ContextHeightOffset;                               // 0x0298(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             IgnoreActorClasses;                                // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngEnvQueryTest_TraceIgnorable">();
	}
	static class UTngEnvQueryTest_TraceIgnorable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngEnvQueryTest_TraceIgnorable>();
	}
};
static_assert(alignof(UTngEnvQueryTest_TraceIgnorable) == 0x000008, "Wrong alignment on UTngEnvQueryTest_TraceIgnorable");
static_assert(sizeof(UTngEnvQueryTest_TraceIgnorable) == 0x0002E8, "Wrong size on UTngEnvQueryTest_TraceIgnorable");
static_assert(offsetof(UTngEnvQueryTest_TraceIgnorable, TraceData) == 0x0001F8, "Member 'UTngEnvQueryTest_TraceIgnorable::TraceData' has a wrong offset!");
static_assert(offsetof(UTngEnvQueryTest_TraceIgnorable, TraceFromContext) == 0x000228, "Member 'UTngEnvQueryTest_TraceIgnorable::TraceFromContext' has a wrong offset!");
static_assert(offsetof(UTngEnvQueryTest_TraceIgnorable, ItemHeightOffset) == 0x000260, "Member 'UTngEnvQueryTest_TraceIgnorable::ItemHeightOffset' has a wrong offset!");
static_assert(offsetof(UTngEnvQueryTest_TraceIgnorable, ContextHeightOffset) == 0x000298, "Member 'UTngEnvQueryTest_TraceIgnorable::ContextHeightOffset' has a wrong offset!");
static_assert(offsetof(UTngEnvQueryTest_TraceIgnorable, Context) == 0x0002D0, "Member 'UTngEnvQueryTest_TraceIgnorable::Context' has a wrong offset!");
static_assert(offsetof(UTngEnvQueryTest_TraceIgnorable, IgnoreActorClasses) == 0x0002D8, "Member 'UTngEnvQueryTest_TraceIgnorable::IgnoreActorClasses' has a wrong offset!");

// Class TangoLib.TngAIController
// 0x0070 (0x03A0 - 0x0330)
class ATngAIController : public AAIController
{
public:
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPostTakeDamage;                                  // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddCombatTargets;                                // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoveCombatTargets;                             // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         InitialTeamID;                                     // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          CombatTargets;                                     // 0x0378(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  CurCombatTarget;                                   // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x10];                                     // 0x0390(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Blueprint_PostTakeDamage(float Damage, const class UDamageType* DamageType, const struct FHitResult& Hit, const struct FVector& DamageImpulse, class AController* InstigatedBy, class AActor* DamageCauser);
	void ChooseRandomCombatTarget();
	void MoveToward(const struct FVector& Velocity);
	void NotifyTeleported();
	bool PauseMovement();
	void Receive_PostTakeDamage(float Damage, const class UDamageType* DamageType, const struct FHitResult& Hit, const struct FVector& DamageImpulse, class AController* InstigatedBy, class AActor* DamageCauser);
	void ReceiveShootAt();
	void ReceiveSmartLinkReached(class ATngNavLinkProxy* NavLink, const struct FVector& Destination);
	void ReceiveTeleported();
	bool ResumeMovement();
	void SetDivergenceWhenFollowingWalkway(float NewVal);
	void SetDriveInputMaxSpeed(float NewMaxSpeed);
	void SetGenericTeamId(const struct FGenericTeamId& NewTeamID);
	void TurnBodyForNavLinkMode(const struct FVector& Destination);

	class AActor* GetCombatTarget(int32 Index_0) const;
	int32 GetCombatTargetNum() const;
	class AActor* GetCurrentCombatTarget() const;
	float GetDivergenceWhenFollowingWalkway() const;
	struct FGenericTeamId GetGenericTeamId() const;
	bool IsCurrentCombatTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAIController">();
	}
	static class ATngAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATngAIController>();
	}
};
static_assert(alignof(ATngAIController) == 0x000008, "Wrong alignment on ATngAIController");
static_assert(sizeof(ATngAIController) == 0x0003A0, "Wrong size on ATngAIController");
static_assert(offsetof(ATngAIController, OnPostTakeDamage) == 0x000340, "Member 'ATngAIController::OnPostTakeDamage' has a wrong offset!");
static_assert(offsetof(ATngAIController, OnAddCombatTargets) == 0x000350, "Member 'ATngAIController::OnAddCombatTargets' has a wrong offset!");
static_assert(offsetof(ATngAIController, OnRemoveCombatTargets) == 0x000360, "Member 'ATngAIController::OnRemoveCombatTargets' has a wrong offset!");
static_assert(offsetof(ATngAIController, InitialTeamID) == 0x000370, "Member 'ATngAIController::InitialTeamID' has a wrong offset!");
static_assert(offsetof(ATngAIController, CombatTargets) == 0x000378, "Member 'ATngAIController::CombatTargets' has a wrong offset!");
static_assert(offsetof(ATngAIController, CurCombatTarget) == 0x000388, "Member 'ATngAIController::CurCombatTarget' has a wrong offset!");

// Class TangoLib.TngAIPerceptionSystem
// 0x0000 (0x0130 - 0x0130)
class UTngAIPerceptionSystem : public UAIPerceptionSystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAIPerceptionSystem">();
	}
	static class UTngAIPerceptionSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAIPerceptionSystem>();
	}
};
static_assert(alignof(UTngAIPerceptionSystem) == 0x000008, "Wrong alignment on UTngAIPerceptionSystem");
static_assert(sizeof(UTngAIPerceptionSystem) == 0x000130, "Wrong size on UTngAIPerceptionSystem");

// Class TangoLib.TngAISense_Damage
// 0x0010 (0x0090 - 0x0080)
class UTngAISense_Damage final : public UAISense
{
public:
	TArray<struct FTngAIDamageEvent>              RegisteredEvents;                                  // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static void ReportDamageEvent(class UObject* WorldContextObject, class AActor* DamagedActor, class AActor* Instigator, float DamageAmount, const struct FVector& EventLocation, const struct FVector& HitLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAISense_Damage">();
	}
	static class UTngAISense_Damage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAISense_Damage>();
	}
};
static_assert(alignof(UTngAISense_Damage) == 0x000008, "Wrong alignment on UTngAISense_Damage");
static_assert(sizeof(UTngAISense_Damage) == 0x000090, "Wrong size on UTngAISense_Damage");
static_assert(offsetof(UTngAISense_Damage, RegisteredEvents) == 0x000080, "Member 'UTngAISense_Damage::RegisteredEvents' has a wrong offset!");

// Class TangoLib.TngAISenseConfig_Damage
// 0x0008 (0x0050 - 0x0048)
class UTngAISenseConfig_Damage final : public UAISenseConfig
{
public:
	TSubclassOf<class UTngAISense_Damage>         Implementation;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAISenseConfig_Damage">();
	}
	static class UTngAISenseConfig_Damage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAISenseConfig_Damage>();
	}
};
static_assert(alignof(UTngAISenseConfig_Damage) == 0x000008, "Wrong alignment on UTngAISenseConfig_Damage");
static_assert(sizeof(UTngAISenseConfig_Damage) == 0x000050, "Wrong size on UTngAISenseConfig_Damage");
static_assert(offsetof(UTngAISenseConfig_Damage, Implementation) == 0x000048, "Member 'UTngAISenseConfig_Damage::Implementation' has a wrong offset!");

// Class TangoLib.TngAISenseEvent_Damage
// 0x0038 (0x0060 - 0x0028)
class UTngAISenseEvent_Damage final : public UAISenseEvent
{
public:
	struct FTngAIDamageEvent                      Event;                                             // 0x0028(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAISenseEvent_Damage">();
	}
	static class UTngAISenseEvent_Damage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAISenseEvent_Damage>();
	}
};
static_assert(alignof(UTngAISenseEvent_Damage) == 0x000008, "Wrong alignment on UTngAISenseEvent_Damage");
static_assert(sizeof(UTngAISenseEvent_Damage) == 0x000060, "Wrong size on UTngAISenseEvent_Damage");
static_assert(offsetof(UTngAISenseEvent_Damage, Event) == 0x000028, "Member 'UTngAISenseEvent_Damage::Event' has a wrong offset!");

// Class TangoLib.TngAnimInstance
// 0x0270 (0x0530 - 0x02C0)
#pragma pack(push, 0x1)
class alignas(0x10) UTngAnimInstance : public UAnimInstance
{
public:
	FMulticastInlineDelegateProperty_             OnBeginCoopAnim;                                   // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndCoopAnim;                                     // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x20];                                     // 0x02D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IdleIndex;                                         // 0x02F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETngCoopAnimState                             CoopAnimState;                                     // 0x02FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETngCoopAnimRole                              CoopAnimRole;                                      // 0x02FD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETngCoopAnimDataType                          CoopAnimDataType;                                  // 0x02FE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FF[0x1];                                      // 0x02FF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      CoopAnimSeqBase;                                   // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTngCoopAnimSlaveInfo>          CoopAnimSlaveInfo;                                 // 0x0308(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CoopAnimMontage;                                   // 0x0318(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0xC];                                      // 0x0320(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsPlayingCoopAnim;                                // 0x032C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCoopAnimPosAdjust;                                // 0x032D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32E[0x106];                                    // 0x032E(0x0106)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableSpecifyLeadLocation;                        // 0x0434(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_435[0x3];                                      // 0x0435(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpecifyLeadAngleThreshold;                         // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpecifyLeadLocationInterpTime;                     // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             BlockCheckOffsetTransform;                         // 0x0440(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	ETngBlockCheckShapeType                       BlockCheckShapeType;                               // 0x0470(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_471[0x3];                                      // 0x0471(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BlockCheckBoxExtent;                               // 0x0474(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlockCheckSphereRadius;                            // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlockCheckCapsuleRadius;                           // 0x0484(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlockCheckCapsuleHeight;                           // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           BlockCheckIgnoreActorList;                         // 0x0490(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	ECollisionChannel                             BlockCheckChannel;                                 // 0x04A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCollisionResponseContainer            BlockCheckResponse;                                // 0x04A1(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C1[0x47];                                     // 0x04C1(0x0047)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTngExtraPlayQueueData>         ExtraAnimQueue;                                    // 0x0508(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_518[0x10];                                     // 0x0518(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CancelCoopAnimation(float BlendOutTime);
	void ForceMeshUpdateFlagToTickAndRefresh(float Duration);
	struct FHitResult GetCurrentRootMoveHitResult();
	struct FTransform GetCurrentRootMoveVelocityTransform();
	struct FTransform GetRootMotionCurveValue();
	struct FTransform GetRootMotionCurveValueAtRotVelocity(float DeltaSeconds);
	float GetStateWeight(class FName MachineName, class FName StateName);
	bool IsAnyStateActive(class FName MachineName, const TArray<class FName>& StateNames, float ThresholdWeight);
	bool IsStateActive(class FName MachineName, class FName StateName, float ThresholdWeight);
	struct FHitResult ModifySweepMove(const struct FVector& InDeltaMove, struct FVector* OutDeltaMove);
	void OnBeginCoopAnimation();
	void OnEndCoopAnimation();
	void OnUpdateCoopAnimationAsMaster();
	void OnUpdateCoopAnimationAsSlave(class UTngAnimInstance* Master, const struct FVector& NewLocation, const struct FRotator& NewRotation, float ElaspedTime);
	bool PlayCoopAnimation(const struct FTngCoopAnimPlayParam& CoopAnimPlayParam, float PlayRate, class FName MontageSectionName);
	bool PlayExtraAnimation(const struct FTngPlayAnimData& InAnimData, ETngPlayAnimTransit TransitType);
	void RemoveDelegateOnBeginExtraAnim(TDelegate<void()> CallbackFunc);
	void RemoveDelegateOnChangeStateExtraAnim(TDelegate<void(ETngExtraPlayState NewState)> CallbackFunc);
	void RemoveDelegateOnCompletedExtraAnim(TDelegate<void(class FName ContactTag)> CallbackFunc);
	void SetCoopAnimPosAdjust(bool _Enable);
	void SetDelegateOnBeginExtraAnim(TDelegate<void()> CallbackFunc);
	void SetDelegateOnChangeStateExtraAnim(TDelegate<void(ETngExtraPlayState NewState)> CallbackFunc);
	void SetDelegateOnCompletedExtraAnim(TDelegate<void(class FName ContactTag)> CallbackFunc);
	void StopExtraAnimation(float BlendOutTime);
	void UpdateRootMotionCurveMove(float DeltaSeconds, bool bSweep);

	void GetExtraAnimPlayBlendInOut(float* InTime, float* OutTime) const;
	float GetExtraAnimPlayBlendInTime() const;
	float GetExtraAnimPlayBlendOutTime() const;
	class UTngCharacterMovementComponent* GetOwningCharacterMovement() const;
	class ATngCharacter* GetOwningTngCharacter() const;
	bool HasRootMotionCurveData() const;
	bool IsActiveExtraAnim() const;
	bool IsAnyPlayingSlotAnimation(class FName SlotNodeName) const;
	bool IsCompatibleAnim(class UAnimSequenceBase* AnimAsset) const;
	bool IsMontagePlaying(class FName SlotName) const;
	bool IsPlayingExtraAnim() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAnimInstance">();
	}
	static class UTngAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTngAnimInstance) == 0x000010, "Wrong alignment on UTngAnimInstance");
static_assert(sizeof(UTngAnimInstance) == 0x000530, "Wrong size on UTngAnimInstance");
static_assert(offsetof(UTngAnimInstance, OnBeginCoopAnim) == 0x0002B8, "Member 'UTngAnimInstance::OnBeginCoopAnim' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, OnEndCoopAnim) == 0x0002C8, "Member 'UTngAnimInstance::OnEndCoopAnim' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, IdleIndex) == 0x0002F8, "Member 'UTngAnimInstance::IdleIndex' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, CoopAnimState) == 0x0002FC, "Member 'UTngAnimInstance::CoopAnimState' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, CoopAnimRole) == 0x0002FD, "Member 'UTngAnimInstance::CoopAnimRole' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, CoopAnimDataType) == 0x0002FE, "Member 'UTngAnimInstance::CoopAnimDataType' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, CoopAnimSeqBase) == 0x000300, "Member 'UTngAnimInstance::CoopAnimSeqBase' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, CoopAnimSlaveInfo) == 0x000308, "Member 'UTngAnimInstance::CoopAnimSlaveInfo' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, CoopAnimMontage) == 0x000318, "Member 'UTngAnimInstance::CoopAnimMontage' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, bIsPlayingCoopAnim) == 0x00032C, "Member 'UTngAnimInstance::bIsPlayingCoopAnim' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, bCoopAnimPosAdjust) == 0x00032D, "Member 'UTngAnimInstance::bCoopAnimPosAdjust' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, bEnableSpecifyLeadLocation) == 0x000434, "Member 'UTngAnimInstance::bEnableSpecifyLeadLocation' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, SpecifyLeadAngleThreshold) == 0x000438, "Member 'UTngAnimInstance::SpecifyLeadAngleThreshold' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, SpecifyLeadLocationInterpTime) == 0x00043C, "Member 'UTngAnimInstance::SpecifyLeadLocationInterpTime' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, BlockCheckOffsetTransform) == 0x000440, "Member 'UTngAnimInstance::BlockCheckOffsetTransform' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, BlockCheckShapeType) == 0x000470, "Member 'UTngAnimInstance::BlockCheckShapeType' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, BlockCheckBoxExtent) == 0x000474, "Member 'UTngAnimInstance::BlockCheckBoxExtent' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, BlockCheckSphereRadius) == 0x000480, "Member 'UTngAnimInstance::BlockCheckSphereRadius' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, BlockCheckCapsuleRadius) == 0x000484, "Member 'UTngAnimInstance::BlockCheckCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, BlockCheckCapsuleHeight) == 0x000488, "Member 'UTngAnimInstance::BlockCheckCapsuleHeight' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, BlockCheckIgnoreActorList) == 0x000490, "Member 'UTngAnimInstance::BlockCheckIgnoreActorList' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, BlockCheckChannel) == 0x0004A0, "Member 'UTngAnimInstance::BlockCheckChannel' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, BlockCheckResponse) == 0x0004A1, "Member 'UTngAnimInstance::BlockCheckResponse' has a wrong offset!");
static_assert(offsetof(UTngAnimInstance, ExtraAnimQueue) == 0x000508, "Member 'UTngAnimInstance::ExtraAnimQueue' has a wrong offset!");

// Class TangoLib.TngAnimInstanceUtility
// 0x0000 (0x0028 - 0x0028)
class UTngAnimInstanceUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UTngAnimInstance* GetTngAnimInstance(class USkeletalMeshComponent* SkelMeshComp);
	static class UTngAnimInstance* GetTngAnimInstanceFromActor(class AActor* Actor);
	static struct FTngCoopAnimPlayParam MakeCoopAnimPlayParamForPair(class AActor* Master, class AActor* Slave, class UTngCoopAnimAsset* Asset);
	static struct FTngCoopAnimPlayParam MakeCoopAnimPlayParamForTrio(class AActor* Master, class AActor* Slave1, class AActor* Slave2, class UTngCoopAnimAsset* Asset);
	static bool PlayExtraAnimationUtil(class UAnimInstance* Instance, const struct FTngPlayAnimData& InAnimData, ETngPlayAnimTransit TransitType);
	static void StopExtraAnimationUtil(class UAnimInstance* Instance, float BlendOutTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAnimInstanceUtility">();
	}
	static class UTngAnimInstanceUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAnimInstanceUtility>();
	}
};
static_assert(alignof(UTngAnimInstanceUtility) == 0x000008, "Wrong alignment on UTngAnimInstanceUtility");
static_assert(sizeof(UTngAnimInstanceUtility) == 0x000028, "Wrong size on UTngAnimInstanceUtility");

// Class TangoLib.TngGameMode
// 0x0060 (0x0328 - 0x02C8)
class ATngGameMode : public AGameModeBase
{
public:
	uint8                                         Pad_2C8[0x38];                                     // 0x02C8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AudioPauseEvent;                                   // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AudioUnpauseEvent;                                 // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngGameMode">();
	}
	static class ATngGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATngGameMode>();
	}
};
static_assert(alignof(ATngGameMode) == 0x000008, "Wrong alignment on ATngGameMode");
static_assert(sizeof(ATngGameMode) == 0x000328, "Wrong size on ATngGameMode");
static_assert(offsetof(ATngGameMode, AudioPauseEvent) == 0x000300, "Member 'ATngGameMode::AudioPauseEvent' has a wrong offset!");
static_assert(offsetof(ATngGameMode, AudioUnpauseEvent) == 0x000308, "Member 'ATngGameMode::AudioUnpauseEvent' has a wrong offset!");

// Class TangoLib.TngAnimNotify_InvokeAbility
// 0x0020 (0x0058 - 0x0038)
class UTngAnimNotify_InvokeAbility final : public UAnimNotify
{
public:
	struct FGameplayTagContainer                  SendTags;                                          // 0x0038(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAnimNotify_InvokeAbility">();
	}
	static class UTngAnimNotify_InvokeAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAnimNotify_InvokeAbility>();
	}
};
static_assert(alignof(UTngAnimNotify_InvokeAbility) == 0x000008, "Wrong alignment on UTngAnimNotify_InvokeAbility");
static_assert(sizeof(UTngAnimNotify_InvokeAbility) == 0x000058, "Wrong size on UTngAnimNotify_InvokeAbility");
static_assert(offsetof(UTngAnimNotify_InvokeAbility, SendTags) == 0x000038, "Member 'UTngAnimNotify_InvokeAbility::SendTags' has a wrong offset!");

// Class TangoLib.TngImpactEffectTable
// 0x0060 (0x0090 - 0x0030)
class UTngImpactEffectTable final : public UDataAsset
{
public:
	struct FTngImpactEffect                       DefaultImpactEffect;                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, struct FTngImpactEffect> EffectTable;                                       // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngImpactEffectTable">();
	}
	static class UTngImpactEffectTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngImpactEffectTable>();
	}
};
static_assert(alignof(UTngImpactEffectTable) == 0x000008, "Wrong alignment on UTngImpactEffectTable");
static_assert(sizeof(UTngImpactEffectTable) == 0x000090, "Wrong size on UTngImpactEffectTable");
static_assert(offsetof(UTngImpactEffectTable, DefaultImpactEffect) == 0x000030, "Member 'UTngImpactEffectTable::DefaultImpactEffect' has a wrong offset!");
static_assert(offsetof(UTngImpactEffectTable, EffectTable) == 0x000040, "Member 'UTngImpactEffectTable::EffectTable' has a wrong offset!");

// Class TangoLib.TngAnimNotifyState_InvokeAbility
// 0x0040 (0x0070 - 0x0030)
class UTngAnimNotifyState_InvokeAbility final : public UAnimNotifyState
{
public:
	struct FGameplayTagContainer                  BeginTags;                                         // 0x0030(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  EndTags;                                           // 0x0050(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAnimNotifyState_InvokeAbility">();
	}
	static class UTngAnimNotifyState_InvokeAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAnimNotifyState_InvokeAbility>();
	}
};
static_assert(alignof(UTngAnimNotifyState_InvokeAbility) == 0x000008, "Wrong alignment on UTngAnimNotifyState_InvokeAbility");
static_assert(sizeof(UTngAnimNotifyState_InvokeAbility) == 0x000070, "Wrong size on UTngAnimNotifyState_InvokeAbility");
static_assert(offsetof(UTngAnimNotifyState_InvokeAbility, BeginTags) == 0x000030, "Member 'UTngAnimNotifyState_InvokeAbility::BeginTags' has a wrong offset!");
static_assert(offsetof(UTngAnimNotifyState_InvokeAbility, EndTags) == 0x000050, "Member 'UTngAnimNotifyState_InvokeAbility::EndTags' has a wrong offset!");

// Class TangoLib.TngAnimNotify_InvokeEquip
// 0x0030 (0x0068 - 0x0038)
class UTngAnimNotify_InvokeEquip final : public UAnimNotify
{
public:
	struct FGameplayTagContainer                  SendTags;                                          // 0x0038(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FName                                   SendSlot;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTngEquipAdvanceParamBase*              AdvanceParam;                                      // 0x0060(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAnimNotify_InvokeEquip">();
	}
	static class UTngAnimNotify_InvokeEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAnimNotify_InvokeEquip>();
	}
};
static_assert(alignof(UTngAnimNotify_InvokeEquip) == 0x000008, "Wrong alignment on UTngAnimNotify_InvokeEquip");
static_assert(sizeof(UTngAnimNotify_InvokeEquip) == 0x000068, "Wrong size on UTngAnimNotify_InvokeEquip");
static_assert(offsetof(UTngAnimNotify_InvokeEquip, SendTags) == 0x000038, "Member 'UTngAnimNotify_InvokeEquip::SendTags' has a wrong offset!");
static_assert(offsetof(UTngAnimNotify_InvokeEquip, SendSlot) == 0x000058, "Member 'UTngAnimNotify_InvokeEquip::SendSlot' has a wrong offset!");
static_assert(offsetof(UTngAnimNotify_InvokeEquip, AdvanceParam) == 0x000060, "Member 'UTngAnimNotify_InvokeEquip::AdvanceParam' has a wrong offset!");

// Class TangoLib.TngGameInstance
// 0x0088 (0x0230 - 0x01A8)
class UTngGameInstance : public UGameInstance
{
public:
	TArray<class UTngGameSystem*>                 GameSystemList;                                    // 0x01A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           DefaultGameSystemBP;                               // 0x01C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x58];                                     // 0x01D8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngGameInstance">();
	}
	static class UTngGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngGameInstance>();
	}
};
static_assert(alignof(UTngGameInstance) == 0x000008, "Wrong alignment on UTngGameInstance");
static_assert(sizeof(UTngGameInstance) == 0x000230, "Wrong size on UTngGameInstance");
static_assert(offsetof(UTngGameInstance, GameSystemList) == 0x0001A8, "Member 'UTngGameInstance::GameSystemList' has a wrong offset!");
static_assert(offsetof(UTngGameInstance, DefaultGameSystemBP) == 0x0001C8, "Member 'UTngGameInstance::DefaultGameSystemBP' has a wrong offset!");

// Class TangoLib.TngAnimNotifyState_InvokeEquip
// 0x00B8 (0x00E8 - 0x0030)
class UTngAnimNotifyState_InvokeEquip final : public UAnimNotifyState
{
public:
	struct FGameplayTagContainer                  BeginTags;                                         // 0x0030(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  EndTags;                                           // 0x0050(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CancelTags;                                        // 0x0070(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FName                                   SendSlot;                                          // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x50];                                      // 0x0098(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAnimNotifyState_InvokeEquip">();
	}
	static class UTngAnimNotifyState_InvokeEquip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAnimNotifyState_InvokeEquip>();
	}
};
static_assert(alignof(UTngAnimNotifyState_InvokeEquip) == 0x000008, "Wrong alignment on UTngAnimNotifyState_InvokeEquip");
static_assert(sizeof(UTngAnimNotifyState_InvokeEquip) == 0x0000E8, "Wrong size on UTngAnimNotifyState_InvokeEquip");
static_assert(offsetof(UTngAnimNotifyState_InvokeEquip, BeginTags) == 0x000030, "Member 'UTngAnimNotifyState_InvokeEquip::BeginTags' has a wrong offset!");
static_assert(offsetof(UTngAnimNotifyState_InvokeEquip, EndTags) == 0x000050, "Member 'UTngAnimNotifyState_InvokeEquip::EndTags' has a wrong offset!");
static_assert(offsetof(UTngAnimNotifyState_InvokeEquip, CancelTags) == 0x000070, "Member 'UTngAnimNotifyState_InvokeEquip::CancelTags' has a wrong offset!");
static_assert(offsetof(UTngAnimNotifyState_InvokeEquip, SendSlot) == 0x000090, "Member 'UTngAnimNotifyState_InvokeEquip::SendSlot' has a wrong offset!");

// Class TangoLib.TngNavLinkProxy
// 0x0008 (0x0280 - 0x0278)
class ATngNavLinkProxy final : public ANavLinkProxy
{
public:
	bool                                          bGenerateReachedAtExitEvent;                       // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AgentTeleportTo(class AActor* Agent, const struct FVector& DestLocation, const struct FRotator& DestRotation);
	bool FindPairLocation(const struct FVector& TestLocation, struct FVector* DestLocation);
	void PauseMove(class AActor* Agent);
	void ReceiveSmartLinkReachedAtExit(class AActor* Agent, const struct FVector& Destination);
	void ResumeMove(class AActor* Agent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngNavLinkProxy">();
	}
	static class ATngNavLinkProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATngNavLinkProxy>();
	}
};
static_assert(alignof(ATngNavLinkProxy) == 0x000008, "Wrong alignment on ATngNavLinkProxy");
static_assert(sizeof(ATngNavLinkProxy) == 0x000280, "Wrong size on ATngNavLinkProxy");
static_assert(offsetof(ATngNavLinkProxy, bGenerateReachedAtExitEvent) == 0x000278, "Member 'ATngNavLinkProxy::bGenerateReachedAtExitEvent' has a wrong offset!");

// Class TangoLib.TngAnimNotifyState_VisibleEquipment
// 0x0010 (0x0040 - 0x0030)
class UTngAnimNotifyState_VisibleEquipment final : public UAnimNotifyState
{
public:
	bool                                          bHidden;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTngEquipVisibleParam                  VisibleParam;                                      // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAnimNotifyState_VisibleEquipment">();
	}
	static class UTngAnimNotifyState_VisibleEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAnimNotifyState_VisibleEquipment>();
	}
};
static_assert(alignof(UTngAnimNotifyState_VisibleEquipment) == 0x000008, "Wrong alignment on UTngAnimNotifyState_VisibleEquipment");
static_assert(sizeof(UTngAnimNotifyState_VisibleEquipment) == 0x000040, "Wrong size on UTngAnimNotifyState_VisibleEquipment");
static_assert(offsetof(UTngAnimNotifyState_VisibleEquipment, bHidden) == 0x000030, "Member 'UTngAnimNotifyState_VisibleEquipment::bHidden' has a wrong offset!");
static_assert(offsetof(UTngAnimNotifyState_VisibleEquipment, VisibleParam) == 0x000034, "Member 'UTngAnimNotifyState_VisibleEquipment::VisibleParam' has a wrong offset!");

// Class TangoLib.TngAnimNotifyState_WeaponAttack
// 0x0028 (0x0058 - 0x0030)
class UTngAnimNotifyState_WeaponAttack final : public UAnimNotifyState
{
public:
	struct FGameplayTag                           GameplayTagWhenBegin;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                AdvanceParamWhenBegin;                             // 0x0038(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           GameplayTagWhenEnd;                                // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                AdvanceParamWhenEnd;                               // 0x0048(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGenerateEventToOwnerActor;                        // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAnimNotifyState_WeaponAttack">();
	}
	static class UTngAnimNotifyState_WeaponAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAnimNotifyState_WeaponAttack>();
	}
};
static_assert(alignof(UTngAnimNotifyState_WeaponAttack) == 0x000008, "Wrong alignment on UTngAnimNotifyState_WeaponAttack");
static_assert(sizeof(UTngAnimNotifyState_WeaponAttack) == 0x000058, "Wrong size on UTngAnimNotifyState_WeaponAttack");
static_assert(offsetof(UTngAnimNotifyState_WeaponAttack, GameplayTagWhenBegin) == 0x000030, "Member 'UTngAnimNotifyState_WeaponAttack::GameplayTagWhenBegin' has a wrong offset!");
static_assert(offsetof(UTngAnimNotifyState_WeaponAttack, AdvanceParamWhenBegin) == 0x000038, "Member 'UTngAnimNotifyState_WeaponAttack::AdvanceParamWhenBegin' has a wrong offset!");
static_assert(offsetof(UTngAnimNotifyState_WeaponAttack, GameplayTagWhenEnd) == 0x000040, "Member 'UTngAnimNotifyState_WeaponAttack::GameplayTagWhenEnd' has a wrong offset!");
static_assert(offsetof(UTngAnimNotifyState_WeaponAttack, AdvanceParamWhenEnd) == 0x000048, "Member 'UTngAnimNotifyState_WeaponAttack::AdvanceParamWhenEnd' has a wrong offset!");
static_assert(offsetof(UTngAnimNotifyState_WeaponAttack, bGenerateEventToOwnerActor) == 0x000050, "Member 'UTngAnimNotifyState_WeaponAttack::bGenerateEventToOwnerActor' has a wrong offset!");

// Class TangoLib.TngAnimNotifyStateInterface
// 0x0000 (0x0028 - 0x0028)
class ITngAnimNotifyStateInterface final : public IInterface
{
public:
	bool BlueprintNative_NotifyStateBegin(const class UAnimNotifyState* AnimNotify, class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration, const struct FGameplayTag& GameplayTag);
	bool BlueprintNative_NotifyStateEnd(const class UAnimNotifyState* AnimNotify, class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, const struct FGameplayTag& GameplayTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAnimNotifyStateInterface">();
	}
	static class ITngAnimNotifyStateInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITngAnimNotifyStateInterface>();
	}
};
static_assert(alignof(ITngAnimNotifyStateInterface) == 0x000008, "Wrong alignment on ITngAnimNotifyStateInterface");
static_assert(sizeof(ITngAnimNotifyStateInterface) == 0x000028, "Wrong size on ITngAnimNotifyStateInterface");

// Class TangoLib.TngApplicationFunction
// 0x0000 (0x0028 - 0x0028)
class UTngApplicationFunction final : public UBlueprintFunctionLibrary
{
public:
	static bool CanEverRender();
	static bool IsConsoleMachine();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngApplicationFunction">();
	}
	static class UTngApplicationFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngApplicationFunction>();
	}
};
static_assert(alignof(UTngApplicationFunction) == 0x000008, "Wrong alignment on UTngApplicationFunction");
static_assert(sizeof(UTngApplicationFunction) == 0x000028, "Wrong size on UTngApplicationFunction");

// Class TangoLib.TngInteractComponent
// 0x00A0 (0x02A0 - 0x0200)
#pragma pack(push, 0x1)
class alignas(0x10) UTngInteractComponent : public USceneComponent
{
public:
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnShouldInteract;                                  // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBeginInteract;                                   // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateInteract;                                  // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndInteract;                                     // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InteractTags;                                      // 0x0240(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SleepTags;                                         // 0x0260(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x18];                                     // 0x0280(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Blueprint_BeginInteract(class AActor* SendActor, const struct FGameplayTag& Tag, class UObject* AdvanceObject);
	void Blueprint_EndInteract(class AActor* SendActor, const struct FGameplayTag& Tag, class UObject* AdvanceObject);
	bool Blueprint_ShouldInteract(class AActor* SendActor, const struct FGameplayTag& Tag);
	void Blueprint_UpdateInteract(class AActor* SendActor, const struct FGameplayTag& Tag, class UObject* AdvanceObject);
	bool CheckSleepInteract(const struct FGameplayTag& Tag);
	void ClearSleepInteract();
	void InitializeInteractTags(const struct FGameplayTagContainer& Tags);
	bool IsValidTag(const struct FGameplayTag& Tag);
	void SetReturnFlag(bool ReturnBool);
	void SleepInteract(const struct FGameplayTag& Tag);
	void SleepInteractAll();
	void ToggleSleepInteract();
	void WakeUpInteract(const struct FGameplayTag& Tag);
	void WakeUpInteractAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngInteractComponent">();
	}
	static class UTngInteractComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngInteractComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTngInteractComponent) == 0x000010, "Wrong alignment on UTngInteractComponent");
static_assert(sizeof(UTngInteractComponent) == 0x0002A0, "Wrong size on UTngInteractComponent");
static_assert(offsetof(UTngInteractComponent, OnShouldInteract) == 0x000200, "Member 'UTngInteractComponent::OnShouldInteract' has a wrong offset!");
static_assert(offsetof(UTngInteractComponent, OnBeginInteract) == 0x000210, "Member 'UTngInteractComponent::OnBeginInteract' has a wrong offset!");
static_assert(offsetof(UTngInteractComponent, OnUpdateInteract) == 0x000220, "Member 'UTngInteractComponent::OnUpdateInteract' has a wrong offset!");
static_assert(offsetof(UTngInteractComponent, OnEndInteract) == 0x000230, "Member 'UTngInteractComponent::OnEndInteract' has a wrong offset!");
static_assert(offsetof(UTngInteractComponent, InteractTags) == 0x000240, "Member 'UTngInteractComponent::InteractTags' has a wrong offset!");
static_assert(offsetof(UTngInteractComponent, SleepTags) == 0x000260, "Member 'UTngInteractComponent::SleepTags' has a wrong offset!");

// Class TangoLib.TngAttackComponent
// 0x00B0 (0x02B0 - 0x0200)
class UTngAttackComponent final : public USceneComponent
{
public:
	float                                         DamageAmount;                                      // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTngDamageType>             DamageType;                                        // 0x0200(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETngAttackTraceType                           AttackTraceType;                                   // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackRadius;                                      // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight;                                 // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxHalfSize;                                       // 0x0214(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttackSocket;                                      // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0229(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A[0x6];                                      // 0x022A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTngImpactEffectTable*                  ImpactEffectTable;                                 // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFriendlyFire;                               // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0239(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A[0x6];                                      // 0x023A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHitDelegate;                                     // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTngAttackHitLog>               AttackHitLogs;                                     // 0x0250(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0260(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class APawn*                                  Instigator;                                        // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AActor>>             HitIgnoreActors;                                   // 0x0278(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x28];                                     // 0x0288(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginAttack();
	void EndAttack();
	void RefreshAttack();

	bool IsAttacking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngAttackComponent">();
	}
	static class UTngAttackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngAttackComponent>();
	}
};
static_assert(alignof(UTngAttackComponent) == 0x000010, "Wrong alignment on UTngAttackComponent");
static_assert(sizeof(UTngAttackComponent) == 0x0002B0, "Wrong size on UTngAttackComponent");
static_assert(offsetof(UTngAttackComponent, DamageAmount) == 0x0001F8, "Member 'UTngAttackComponent::DamageAmount' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, DamageType) == 0x000200, "Member 'UTngAttackComponent::DamageType' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, AttackTraceType) == 0x000208, "Member 'UTngAttackComponent::AttackTraceType' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, AttackRadius) == 0x00020C, "Member 'UTngAttackComponent::AttackRadius' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, CapsuleHalfHeight) == 0x000210, "Member 'UTngAttackComponent::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, BoxHalfSize) == 0x000214, "Member 'UTngAttackComponent::BoxHalfSize' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, AttackSocket) == 0x000220, "Member 'UTngAttackComponent::AttackSocket' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, TraceChannel) == 0x000228, "Member 'UTngAttackComponent::TraceChannel' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, bTraceComplex) == 0x000229, "Member 'UTngAttackComponent::bTraceComplex' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, ImpactEffectTable) == 0x000230, "Member 'UTngAttackComponent::ImpactEffectTable' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, bEnableFriendlyFire) == 0x000238, "Member 'UTngAttackComponent::bEnableFriendlyFire' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, DrawDebugType) == 0x000239, "Member 'UTngAttackComponent::DrawDebugType' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, OnHitDelegate) == 0x000240, "Member 'UTngAttackComponent::OnHitDelegate' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, AttackHitLogs) == 0x000250, "Member 'UTngAttackComponent::AttackHitLogs' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, IgnoreActors) == 0x000260, "Member 'UTngAttackComponent::IgnoreActors' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, Instigator) == 0x000270, "Member 'UTngAttackComponent::Instigator' has a wrong offset!");
static_assert(offsetof(UTngAttackComponent, HitIgnoreActors) == 0x000278, "Member 'UTngAttackComponent::HitIgnoreActors' has a wrong offset!");

// Class TangoLib.TngBoundaryComponent
// 0x0030 (0x0230 - 0x0200)
class UTngBoundaryComponent final : public USceneComponent
{
public:
	TArray<struct FTngBoundaryData>               BoundaryList;                                      // 0x01F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x28];                                     // 0x0208(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetRandomPointInNavigableBoundary(struct FVector* OutPoint) const;
	bool IsInside(const struct FVector& CheckLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngBoundaryComponent">();
	}
	static class UTngBoundaryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngBoundaryComponent>();
	}
};
static_assert(alignof(UTngBoundaryComponent) == 0x000010, "Wrong alignment on UTngBoundaryComponent");
static_assert(sizeof(UTngBoundaryComponent) == 0x000230, "Wrong size on UTngBoundaryComponent");
static_assert(offsetof(UTngBoundaryComponent, BoundaryList) == 0x0001F8, "Member 'UTngBoundaryComponent::BoundaryList' has a wrong offset!");

// Class TangoLib.TngBTTask_SplineMoveTo
// 0x0008 (0x00B8 - 0x00B0)
class UTngBTTask_SplineMoveTo final : public UBTTask_MoveTo
{
public:
	float                                         DriveInputSpeed;                                   // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseNavPathfinding : 1;                            // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngBTTask_SplineMoveTo">();
	}
	static class UTngBTTask_SplineMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngBTTask_SplineMoveTo>();
	}
};
static_assert(alignof(UTngBTTask_SplineMoveTo) == 0x000008, "Wrong alignment on UTngBTTask_SplineMoveTo");
static_assert(sizeof(UTngBTTask_SplineMoveTo) == 0x0000B8, "Wrong size on UTngBTTask_SplineMoveTo");
static_assert(offsetof(UTngBTTask_SplineMoveTo, DriveInputSpeed) == 0x0000B0, "Member 'UTngBTTask_SplineMoveTo::DriveInputSpeed' has a wrong offset!");

// Class TangoLib.TngPickRelevantInterface
// 0x0000 (0x0028 - 0x0028)
class ITngPickRelevantInterface final : public IInterface
{
public:
	bool BlueprintNative_Pick(class AActor* ToActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngPickRelevantInterface">();
	}
	static class ITngPickRelevantInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITngPickRelevantInterface>();
	}
};
static_assert(alignof(ITngPickRelevantInterface) == 0x000008, "Wrong alignment on ITngPickRelevantInterface");
static_assert(sizeof(ITngPickRelevantInterface) == 0x000028, "Wrong size on ITngPickRelevantInterface");

// Class TangoLib.TngCharacter
// 0x0040 (0x0500 - 0x04C0)
class ATngCharacter : public ACharacter
{
public:
	uint8                                         Pad_4B8[0x10];                                     // 0x04B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPostTakeDamage;                                  // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPostDied;                                        // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bViewRotationIsActorRotation : 1;                  // 0x04E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4E9[0x17];                                     // 0x04E9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindToOnPostCharacterDied(TDelegate<void()> CallbackFunc);
	float GetAnimGraphStateWeight(class FName MachineName, class FName StateName);
	bool IsAnimGraphStateActive(class FName MachineName, class FName StateName, float ThresholdWeight);
	bool IsAnyAnimGraphStateActive(class FName MachineName, const TArray<class FName>& StateNames, float ThresholdWeight);
	void JumpByHeight(float Height);
	void JumpByTarget(const struct FVector& TargetLocation, float JumpHeight, float JumpTime);
	float ModifyAttackDamageAmount(class FName AtkDmgName, float DefaultDmgAmount, TSubclassOf<class UDamageType> DmgType);
	class UAnimMontage* PlaySlotAnimationAsDynamicMontage(class UAnimSequenceBase* Asset, class FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
	void SetBaseTranslationOffset(const struct FVector& SetOffset);
	void SetCharacterDeadFlag(bool bDead);
	void SetIgnoreGravity(bool NewFlag);
	void ShowMaterialSectionBySlotName(class FName MaterialSlotName, bool bShow, int32 LODIndex);
	void StopSlotAnimation(float InBlendOutTime, class FName SlotNodeName);

	struct FVector CalcCharacterLocationFromFooting(const struct FVector& Footing) const;
	float GetHalfHeight() const;
	class UTngAnimInstance* GetTngAnimInstance() const;
	class UTngCharacterMovementComponent* GetTngCharacterMovement() const;
	bool IsCharacterDead() const;
	bool IsCompatibleAnim(class UAnimSequenceBase* AnimAsset) const;
	bool IsPlayingSlotAnimation(const class UAnimSequenceBase* Asset, class FName SlotNodeName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngCharacter">();
	}
	static class ATngCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATngCharacter>();
	}
};
static_assert(alignof(ATngCharacter) == 0x000010, "Wrong alignment on ATngCharacter");
static_assert(sizeof(ATngCharacter) == 0x000500, "Wrong size on ATngCharacter");
static_assert(offsetof(ATngCharacter, OnPostTakeDamage) == 0x0004C8, "Member 'ATngCharacter::OnPostTakeDamage' has a wrong offset!");
static_assert(offsetof(ATngCharacter, OnPostDied) == 0x0004D8, "Member 'ATngCharacter::OnPostDied' has a wrong offset!");

// Class TangoLib.TngCharacterFunction
// 0x0000 (0x0028 - 0x0028)
class UTngCharacterFunction final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector CalcCharacterLocationFromFeet(class ACharacter* Target, const struct FVector& FeetLocation);
	static bool ChangeCharacterCollision(class ACharacter* Target, float HalfHeight, float Radius, bool IsAlignTop, bool IsClampSize, float IsClampTopMrgin);
	static bool SetCharacterOnLanded(class ACharacter* Target, TDelegate<void(struct FHitResult& Hit)> SetCallback);
	static void ShowCharacterMaterialSectionBySlotName(class ACharacter* Target, class FName MaterialSlotName, bool bShow, int32 LODIndex);
	static bool TeleportToActor(class ACharacter* Target, class AActor* DestActor, bool bIsATest, bool bNoCheck, bool bByFeet);
	static bool TeleportToByFeet(class ACharacter* Target, const struct FVector& DestFeetLocation, const struct FRotator& DestRotation, bool bIsATest, bool bNoCheck);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngCharacterFunction">();
	}
	static class UTngCharacterFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngCharacterFunction>();
	}
};
static_assert(alignof(UTngCharacterFunction) == 0x000008, "Wrong alignment on UTngCharacterFunction");
static_assert(sizeof(UTngCharacterFunction) == 0x000028, "Wrong size on UTngCharacterFunction");

// Class TangoLib.TngCharacterMovementComponent
// 0x0160 (0x0C50 - 0x0AF0)
#pragma pack(push, 0x1)
class alignas(0x10) UTngCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_AF0[0x8];                                      // 0x0AF0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AvoidanceAdjustRadius;                             // 0x0AF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DriveInputDir;                                     // 0x0AFC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DriveInputWorldDir;                                // 0x0B08(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DriveInputAimDir;                                  // 0x0B14(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DriveInputMoveAim;                                 // 0x0B20(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FVector                                DriveInputAimLocation;                             // 0x0B2C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DriveInputPivotJointName;                          // 0x0B38(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETngDriveInputJointAxis                       DriveInputPivotJointAxis;                          // 0x0B40(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B41[0x3];                                      // 0x0B41(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DriveInputSpeed;                                   // 0x0B44(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DriveInputMaxSpeed;                                // 0x0B48(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTngDriveInputLockOnItem               DriveInputLockOn;                                  // 0x0B4C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIsDriveInputWorldDir;                             // 0x0B60(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDriveInputStrafing;                               // 0x0B61(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B62[0x2];                                      // 0x0B62(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DriveInputStrafingInterpSpeed;                     // 0x0B64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDriveInputBrake;                                  // 0x0B68(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDriveInputLockOn;                               // 0x0B69(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDriveInputAiming;                                 // 0x0B6A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDebugAvoidance;                                // 0x0B6B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6C[0xC4];                                     // 0x0B6C(0x00C4)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             IgnoreClassTypeOnCapsuleTouched;                   // 0x0C30(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bApplyAccumulatedForcesWhenRootMotion;             // 0x0C40(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C41[0x3];                                      // 0x0C41(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bWasTngAvoidanceUpdated : 1;                       // 0x0C44(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNavLinkFollowing : 1;                             // 0x0C44(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreGravity : 1;                                // 0x0C44(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C45[0x3];                                      // 0x0C45(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcDotProductDriveDirection();
	void DisableModifyRootMotionByRotation();
	void EnableModifyRootMotionByRotation(const struct FRotator& Rot);
	struct FVector GetModifyRootMotionVelocityScale();
	float GetModifyRootMotionYawScale();
	struct FVector GetVewlocityWithoutForces();
	void SetBumpCount(int32 NewCount);
	void SetIgnoreGravity(bool NewFlag);
	void SetModifyRootMotionVelocityScale(const struct FVector& NewScale);
	void SetModifyRootMotionYawScale(float NewScale);

	int32 GetBumpCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngCharacterMovementComponent">();
	}
	static class UTngCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngCharacterMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTngCharacterMovementComponent) == 0x000010, "Wrong alignment on UTngCharacterMovementComponent");
static_assert(sizeof(UTngCharacterMovementComponent) == 0x000C50, "Wrong size on UTngCharacterMovementComponent");
static_assert(offsetof(UTngCharacterMovementComponent, AvoidanceAdjustRadius) == 0x000AF8, "Member 'UTngCharacterMovementComponent::AvoidanceAdjustRadius' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, DriveInputDir) == 0x000AFC, "Member 'UTngCharacterMovementComponent::DriveInputDir' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, DriveInputWorldDir) == 0x000B08, "Member 'UTngCharacterMovementComponent::DriveInputWorldDir' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, DriveInputAimDir) == 0x000B14, "Member 'UTngCharacterMovementComponent::DriveInputAimDir' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, DriveInputMoveAim) == 0x000B20, "Member 'UTngCharacterMovementComponent::DriveInputMoveAim' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, DriveInputAimLocation) == 0x000B2C, "Member 'UTngCharacterMovementComponent::DriveInputAimLocation' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, DriveInputPivotJointName) == 0x000B38, "Member 'UTngCharacterMovementComponent::DriveInputPivotJointName' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, DriveInputPivotJointAxis) == 0x000B40, "Member 'UTngCharacterMovementComponent::DriveInputPivotJointAxis' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, DriveInputSpeed) == 0x000B44, "Member 'UTngCharacterMovementComponent::DriveInputSpeed' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, DriveInputMaxSpeed) == 0x000B48, "Member 'UTngCharacterMovementComponent::DriveInputMaxSpeed' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, DriveInputLockOn) == 0x000B4C, "Member 'UTngCharacterMovementComponent::DriveInputLockOn' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, bIsDriveInputWorldDir) == 0x000B60, "Member 'UTngCharacterMovementComponent::bIsDriveInputWorldDir' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, bDriveInputStrafing) == 0x000B61, "Member 'UTngCharacterMovementComponent::bDriveInputStrafing' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, DriveInputStrafingInterpSpeed) == 0x000B64, "Member 'UTngCharacterMovementComponent::DriveInputStrafingInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, bDriveInputBrake) == 0x000B68, "Member 'UTngCharacterMovementComponent::bDriveInputBrake' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, bIsDriveInputLockOn) == 0x000B69, "Member 'UTngCharacterMovementComponent::bIsDriveInputLockOn' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, bDriveInputAiming) == 0x000B6A, "Member 'UTngCharacterMovementComponent::bDriveInputAiming' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, bUseDebugAvoidance) == 0x000B6B, "Member 'UTngCharacterMovementComponent::bUseDebugAvoidance' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, IgnoreClassTypeOnCapsuleTouched) == 0x000C30, "Member 'UTngCharacterMovementComponent::IgnoreClassTypeOnCapsuleTouched' has a wrong offset!");
static_assert(offsetof(UTngCharacterMovementComponent, bApplyAccumulatedForcesWhenRootMotion) == 0x000C40, "Member 'UTngCharacterMovementComponent::bApplyAccumulatedForcesWhenRootMotion' has a wrong offset!");

// Class TangoLib.TngCharacterMovementInterface
// 0x0000 (0x0028 - 0x0028)
class ITngCharacterMovementInterface final : public IInterface
{
public:
	bool CanDriveInputStrafing();
	void ClearDriveInputAimLocation();
	void ClearDriveInputAimTarget();
	bool FlushDriveInput(struct FTngDriveInfo* DriveInfo);
	bool GetDriveInputInfo(struct FTngDriveInfo* DriveInfo);
	float GetDriveInputMaxSpeed();
	float GetDriveInputStrafingInterpSpeed();
	bool HasDriveInputAimLocation();
	bool HasDriveInputAimTarget();
	void RequestDriveInput(const struct FVector& MoveVelocity);
	void ResetDriveInput();
	void SetDriveInputAiming(bool IsAiming);
	void SetDriveInputAimLocation(const struct FVector& TargetLocation, const class FName& PivotJointName, ETngDriveInputJointAxis JointAxis);
	bool SetDriveInputAimTarget(const struct FVector& AimToLocation, class AActor* AimToActor);
	void SetDriveInputBrake();
	void SetDriveInputMaxSpeed(float NewMaxSpeedRate);
	void SetDriveInputMove(const struct FVector& Direction, float Speed, bool IsWorldDirection);
	void SetDriveInputMoveAim(const struct FRotator& DeltaMove);
	void SetDriveInputSpeed(float NewSpeed);
	void SetDriveInputStrafing(bool IsStrafing);
	void SetDriveInputStrafingInterpSpeed(float InSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngCharacterMovementInterface">();
	}
	static class ITngCharacterMovementInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITngCharacterMovementInterface>();
	}
};
static_assert(alignof(ITngCharacterMovementInterface) == 0x000008, "Wrong alignment on ITngCharacterMovementInterface");
static_assert(sizeof(ITngCharacterMovementInterface) == 0x000028, "Wrong size on ITngCharacterMovementInterface");

// Class TangoLib.TngCoopAnimAsset
// 0x0028 (0x0058 - 0x0030)
class UTngCoopAnimAsset final : public UDataAsset
{
public:
	struct FGameplayTag                           CoopAnimTag;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpLocationTime;                                // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpLocationDelayTime;                           // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCollision;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableGravity;                                   // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageCancel;                                     // 0x0043(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTngCoopAnim>                   DataTable;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngCoopAnimAsset">();
	}
	static class UTngCoopAnimAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngCoopAnimAsset>();
	}
};
static_assert(alignof(UTngCoopAnimAsset) == 0x000008, "Wrong alignment on UTngCoopAnimAsset");
static_assert(sizeof(UTngCoopAnimAsset) == 0x000058, "Wrong size on UTngCoopAnimAsset");
static_assert(offsetof(UTngCoopAnimAsset, CoopAnimTag) == 0x000030, "Member 'UTngCoopAnimAsset::CoopAnimTag' has a wrong offset!");
static_assert(offsetof(UTngCoopAnimAsset, InterpLocationTime) == 0x000038, "Member 'UTngCoopAnimAsset::InterpLocationTime' has a wrong offset!");
static_assert(offsetof(UTngCoopAnimAsset, InterpLocationDelayTime) == 0x00003C, "Member 'UTngCoopAnimAsset::InterpLocationDelayTime' has a wrong offset!");
static_assert(offsetof(UTngCoopAnimAsset, bDisableCollision) == 0x000040, "Member 'UTngCoopAnimAsset::bDisableCollision' has a wrong offset!");
static_assert(offsetof(UTngCoopAnimAsset, bDisableGravity) == 0x000041, "Member 'UTngCoopAnimAsset::bDisableGravity' has a wrong offset!");
static_assert(offsetof(UTngCoopAnimAsset, bSweep) == 0x000042, "Member 'UTngCoopAnimAsset::bSweep' has a wrong offset!");
static_assert(offsetof(UTngCoopAnimAsset, bDamageCancel) == 0x000043, "Member 'UTngCoopAnimAsset::bDamageCancel' has a wrong offset!");
static_assert(offsetof(UTngCoopAnimAsset, DataTable) == 0x000048, "Member 'UTngCoopAnimAsset::DataTable' has a wrong offset!");

// Class TangoLib.TngCrowdCharacter
// 0x0030 (0x0530 - 0x0500)
class ATngCrowdCharacter final : public ATngCharacter
{
public:
	uint8                                         Pad_500[0x30];                                     // 0x0500(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCrowdStreamVelocity(const struct FVector& Velocity);
	void Blueprint_StartCrowdStream();
	void ResetCrowdStreamVelocity();
	void SetCrowdStreamHome(const struct FVector& HomeLocation);
	void SetCrowdStreamLane(float NewLane);
	void SetCrowdStreamOwner(class AActor* NewOwner);
	void SetCrowdStreamRow(float NewRow);
	void SetCrowdStreamTag(int32 NewTag);
	void SetCrowdStreamVelocity(const struct FVector& Velocity);

	struct FVector GetCrowdStreamHome() const;
	float GetCrowdStreamLane() const;
	class AActor* GetCrowdStreamOwner() const;
	float GetCrowdStreamRow() const;
	int32 GetCrowdStreamTag() const;
	struct FVector GetCrowdStreamVelocity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngCrowdCharacter">();
	}
	static class ATngCrowdCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATngCrowdCharacter>();
	}
};
static_assert(alignof(ATngCrowdCharacter) == 0x000010, "Wrong alignment on ATngCrowdCharacter");
static_assert(sizeof(ATngCrowdCharacter) == 0x000530, "Wrong size on ATngCrowdCharacter");

// Class TangoLib.TngDamageSystem
// 0x0000 (0x0038 - 0x0038)
class UTngDamageSystem final : public UTngGameSystem
{
public:
	static float ApplyDamageTNG(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
	static float ApplyPointDamageTNG(class AActor* DamagedActor, float BaseDamage, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
	static bool ApplyRadialDamageTNG(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel);
	static bool ApplyRadialDamageWithFalloffTNG(class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngDamageSystem">();
	}
	static class UTngDamageSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngDamageSystem>();
	}
};
static_assert(alignof(UTngDamageSystem) == 0x000008, "Wrong alignment on UTngDamageSystem");
static_assert(sizeof(UTngDamageSystem) == 0x000038, "Wrong size on UTngDamageSystem");

// Class TangoLib.TngPlayerCameraManager
// 0x0000 (0x2940 - 0x2940)
class ATngPlayerCameraManager final : public APlayerCameraManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngPlayerCameraManager">();
	}
	static class ATngPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATngPlayerCameraManager>();
	}
};
static_assert(alignof(ATngPlayerCameraManager) == 0x000010, "Wrong alignment on ATngPlayerCameraManager");
static_assert(sizeof(ATngPlayerCameraManager) == 0x002940, "Wrong size on ATngPlayerCameraManager");

// Class TangoLib.TngDamageType
// 0x0028 (0x0068 - 0x0040)
class UTngDamageType : public UDamageType
{
public:
	struct FGameplayTagContainer                  DamageTags;                                        // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         DamageDuration;                                    // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetDamageDuration(const class UDamageType* DmgType);
	static struct FGameplayTagContainer GetDamageTagsFromClass(TSubclassOf<class UDamageType> DmgTypeClass);
	static struct FGameplayTagContainer GetDamageTagsFromDamageType(const class UDamageType* DmgType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngDamageType">();
	}
	static class UTngDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngDamageType>();
	}
};
static_assert(alignof(UTngDamageType) == 0x000008, "Wrong alignment on UTngDamageType");
static_assert(sizeof(UTngDamageType) == 0x000068, "Wrong size on UTngDamageType");
static_assert(offsetof(UTngDamageType, DamageTags) == 0x000040, "Member 'UTngDamageType::DamageTags' has a wrong offset!");
static_assert(offsetof(UTngDamageType, DamageDuration) == 0x000060, "Member 'UTngDamageType::DamageDuration' has a wrong offset!");

// Class TangoLib.TngPlayerService
// 0x0010 (0x0038 - 0x0028)
class UTngPlayerService : public UObject
{
public:
	bool                                          bSaveGame;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0xF];                                       // 0x0029(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Blueprint_DisplayDebug(class UCanvas* Canvas);
	void Blueprint_Initialization();
	void Blueprint_PostUpdate(float DeltaSeconds);
	void Blueprint_PreUpdate(float DeltaSeconds);

	class ATngPlayerController* GetOwnerPlayerController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngPlayerService">();
	}
	static class UTngPlayerService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngPlayerService>();
	}
};
static_assert(alignof(UTngPlayerService) == 0x000008, "Wrong alignment on UTngPlayerService");
static_assert(sizeof(UTngPlayerService) == 0x000038, "Wrong size on UTngPlayerService");
static_assert(offsetof(UTngPlayerService, bSaveGame) == 0x000028, "Member 'UTngPlayerService::bSaveGame' has a wrong offset!");

// Class TangoLib.TngDebugBoard
// 0x0028 (0x0060 - 0x0038)
class UTngDebugBoard final : public UTngPlayerService
{
public:
	FMulticastInlineDelegateProperty_             OnDebugBoardDraw;                                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void K2_EntryOnTngDebugBoardDraw(class UObject* WorldContextObject, TDelegate<void(class UCanvas* Canvas)> Temp);
	static void K2_RemoveOnTngDebugBoardDraw(class UObject* WorldContextObject, TDelegate<void(class UCanvas* Canvas)> Temp);
	static class FString Tng64BitmapToString(const int64 Param, int32 ColonType, int32 DrawMax, bool Reverse);
	static class FString TngBitmapToString(const int32 Param, int32 ColonType, int32 DrawMax, bool Reverse);
	static class FString TngBooleanToMark(const bool Param);
	static class FString TngBooleanToString(const bool Param);
	static void TngDebugDraw2DBitmap(class UObject* WorldContextObject, const int32 Param, float PosX, float PosY, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw2DBoolean(class UObject* WorldContextObject, const bool Param, float PosX, float PosY, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw2DFloat(class UObject* WorldContextObject, const float Param, float PosX, float PosY, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw2DGameplayTags(class UObject* WorldContextObject, const struct FGameplayTagContainer& Param, float PosX, float PosY, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw2DInteger(class UObject* WorldContextObject, const int32 Param, float PosX, float PosY, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw2DObject(class UObject* WorldContextObject, const class UObject* Param, float PosX, float PosY, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw2DRotator(class UObject* WorldContextObject, const struct FRotator& Param, float PosX, float PosY, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw2DText(class UObject* WorldContextObject, const class FString& Text, float PosX, float PosY, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw2DVector(class UObject* WorldContextObject, const struct FVector& Param, float PosX, float PosY, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw3DBitmap(class UObject* WorldContextObject, const int32 Param, const struct FVector& Location, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw3DBoolean(class UObject* WorldContextObject, const bool Param, const struct FVector& Location, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw3DFloat(class UObject* WorldContextObject, const float Param, const struct FVector& Location, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw3DGameplayTags(class UObject* WorldContextObject, const struct FGameplayTagContainer& Param, const struct FVector& Location, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw3DInteger(class UObject* WorldContextObject, const int32 Param, const struct FVector& Location, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw3DObject(class UObject* WorldContextObject, const class UObject* Param, const struct FVector& Location, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw3DRotator(class UObject* WorldContextObject, const struct FRotator& Param, const struct FVector& Location, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw3DText(class UObject* WorldContextObject, const class FString& Text, const struct FVector& Location, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDraw3DVector(class UObject* WorldContextObject, const struct FVector& Param, const struct FVector& Location, const struct FLinearColor& Color, float TextScale, float DrawTime, float PopLength);
	static void TngDebugDrawLineActor(class UObject* WorldContextObject, const struct FVector& Location, const class AActor* Param, const struct FLinearColor& Color, float LineScale, float DrawTime);
	static void TngDebugDrawLineActors(class UObject* WorldContextObject, const struct FVector& Location, const TArray<class AActor*>& Param, const struct FLinearColor& Color, float LineScale, float DrawTime);
	static void TngDebugDrawLineLocation(class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& Param, const struct FLinearColor& Color, float LineScale, float DrawTime);
	static class FString TngFloatToString(const float Param);
	static class FString TngGameplayTagsToString(const struct FGameplayTagContainer& Param, bool IsOneLine);
	static class FString TngIntegerToString(const int32 Param);
	static class FString TngObjectToString(const class UObject* Param);
	static class FString TngRotatorToString(const struct FRotator& Param);
	static float TngStrLen(const class UFont* InFont, const class FString& InText, float* XL, float* YL);
	static class FString TngVectorToString(const struct FVector& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngDebugBoard">();
	}
	static class UTngDebugBoard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngDebugBoard>();
	}
};
static_assert(alignof(UTngDebugBoard) == 0x000008, "Wrong alignment on UTngDebugBoard");
static_assert(sizeof(UTngDebugBoard) == 0x000060, "Wrong size on UTngDebugBoard");
static_assert(offsetof(UTngDebugBoard, OnDebugBoardDraw) == 0x000038, "Member 'UTngDebugBoard::OnDebugBoardDraw' has a wrong offset!");

// Class TangoLib.TngDebugCircle
// 0x0048 (0x0080 - 0x0038)
class UTngDebugCircle : public UTngPlayerService
{
public:
	uint8                                         Pad_38[0xC];                                       // 0x0038(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TextSizeRate;                                      // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawPosX;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DrawPosY;                                          // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DrawBlockX;                                        // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DrawBlockY;                                        // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WakeClickTime;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WakePushTime;                                      // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTngDebugCirclePage>            PageList;                                          // 0x0068(0x0010)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool SetDebugCircle(class UObject* WorldContextObject, int32 Page, int32 Index_0, const class FString& SetCommand);
	static void SetDebugCircleEnable(class UObject* WorldContextObject, bool SetFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngDebugCircle">();
	}
	static class UTngDebugCircle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngDebugCircle>();
	}
};
static_assert(alignof(UTngDebugCircle) == 0x000008, "Wrong alignment on UTngDebugCircle");
static_assert(sizeof(UTngDebugCircle) == 0x000080, "Wrong size on UTngDebugCircle");
static_assert(offsetof(UTngDebugCircle, TextSizeRate) == 0x000044, "Member 'UTngDebugCircle::TextSizeRate' has a wrong offset!");
static_assert(offsetof(UTngDebugCircle, DrawPosX) == 0x000050, "Member 'UTngDebugCircle::DrawPosX' has a wrong offset!");
static_assert(offsetof(UTngDebugCircle, DrawPosY) == 0x000054, "Member 'UTngDebugCircle::DrawPosY' has a wrong offset!");
static_assert(offsetof(UTngDebugCircle, DrawBlockX) == 0x000058, "Member 'UTngDebugCircle::DrawBlockX' has a wrong offset!");
static_assert(offsetof(UTngDebugCircle, DrawBlockY) == 0x00005C, "Member 'UTngDebugCircle::DrawBlockY' has a wrong offset!");
static_assert(offsetof(UTngDebugCircle, WakeClickTime) == 0x000060, "Member 'UTngDebugCircle::WakeClickTime' has a wrong offset!");
static_assert(offsetof(UTngDebugCircle, WakePushTime) == 0x000064, "Member 'UTngDebugCircle::WakePushTime' has a wrong offset!");
static_assert(offsetof(UTngDebugCircle, PageList) == 0x000068, "Member 'UTngDebugCircle::PageList' has a wrong offset!");

// Class TangoLib.TngDebugDrawComponent
// 0x0010 (0x0460 - 0x0450)
class UTngDebugDrawComponent final : public UPrimitiveComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDraw;                                            // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static void DrawBoxFromActor(class AActor* Target, const class AActor* A, const struct FVector& Size, const struct FColor& Color);
	static void DrawBoxFromTransform(class AActor* Target, const struct FTransform& A, const struct FVector& Size, const struct FColor& Color);
	static void DrawCircleFromActor(class AActor* Target, const class AActor* A, float Size, const struct FColor& Color);
	static void DrawCircleFromPoint(class AActor* Target, const struct FVector& A, float Size, const struct FColor& Color);
	static void DrawLineFromActorToActor(class AActor* Target, const class AActor* A, const class AActor* B, const struct FColor& Color, bool IsArrow);
	static void DrawLineFromActorToPoint(class AActor* Target, const class AActor* A, const struct FVector& B, const struct FColor& Color, bool IsArrow);
	static void DrawLineFromPointToPoint(class AActor* Target, const struct FVector& A, const struct FVector& B, const struct FColor& Color, bool IsArrow);
	static void DrawPinFromActor(class AActor* Target, const class AActor* A, const struct FVector& Size, const struct FColor& Color);
	static void DrawPinFromPoint(class AActor* Target, const struct FVector& A, const struct FVector& Size, const struct FColor& Color);
	static void DrawSphereFromActor(class AActor* Target, const class AActor* A, float Size, const struct FColor& Color);
	static void DrawSphereFromPoint(class AActor* Target, const struct FVector& A, float Size, const struct FColor& Color);
	static void DrawSphereFromTransform(class AActor* Target, const struct FTransform& A, float Size, const struct FColor& Color);
	static void DrawTextFromActor(class AActor* Target, const class AActor* A, const class FString& Text, const struct FColor& Color);
	static void DrawTextFromPoint(class AActor* Target, const struct FVector& A, const class FString& Text, const struct FColor& Color);
	static void ResetLine(class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngDebugDrawComponent">();
	}
	static class UTngDebugDrawComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngDebugDrawComponent>();
	}
};
static_assert(alignof(UTngDebugDrawComponent) == 0x000010, "Wrong alignment on UTngDebugDrawComponent");
static_assert(sizeof(UTngDebugDrawComponent) == 0x000460, "Wrong size on UTngDebugDrawComponent");
static_assert(offsetof(UTngDebugDrawComponent, OnDraw) == 0x000450, "Member 'UTngDebugDrawComponent::OnDraw' has a wrong offset!");

// Class TangoLib.TngDebugMenu
// 0x0040 (0x0078 - 0x0038)
class UTngDebugMenu final : public UTngPlayerService
{
public:
	TArray<struct FTngDebugMenuItem>              ItemList;                                          // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetDebugMenu(class UObject* WorldContextObject, const class FString& GetName, bool AfterClear);
	static bool GetDebugMenuWithEntry(class UObject* WorldContextObject, const class FString& GetName, bool AfterClear);
	static bool SetDebugMenu(class UObject* WorldContextObject, const class FString& SetName, const class FString& SetCommand);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngDebugMenu">();
	}
	static class UTngDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngDebugMenu>();
	}
};
static_assert(alignof(UTngDebugMenu) == 0x000008, "Wrong alignment on UTngDebugMenu");
static_assert(sizeof(UTngDebugMenu) == 0x000078, "Wrong size on UTngDebugMenu");
static_assert(offsetof(UTngDebugMenu, ItemList) == 0x000038, "Member 'UTngDebugMenu::ItemList' has a wrong offset!");

// Class TangoLib.TngBlackboardData
// 0x0328 (0x0350 - 0x0028)
class UTngBlackboardData final : public UObject
{
public:
	class FName                                   DataName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      FloatList;                                         // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, class UObject*>             ObjectList;                                        // 0x0080(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, class UClass*>              ClassList;                                         // 0x00D0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, uint8>                      EnumList;                                          // 0x0120(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      IntegerList;                                       // 0x0170(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       BooleanList;                                       // 0x01C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, class FString>              StringList;                                        // 0x0210(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                NameList;                                          // 0x0260(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             VectorList;                                        // 0x02B0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, struct FRotator>            RotatorList;                                       // 0x0300(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngBlackboardData">();
	}
	static class UTngBlackboardData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngBlackboardData>();
	}
};
static_assert(alignof(UTngBlackboardData) == 0x000008, "Wrong alignment on UTngBlackboardData");
static_assert(sizeof(UTngBlackboardData) == 0x000350, "Wrong size on UTngBlackboardData");
static_assert(offsetof(UTngBlackboardData, DataName) == 0x000028, "Member 'UTngBlackboardData::DataName' has a wrong offset!");
static_assert(offsetof(UTngBlackboardData, FloatList) == 0x000030, "Member 'UTngBlackboardData::FloatList' has a wrong offset!");
static_assert(offsetof(UTngBlackboardData, ObjectList) == 0x000080, "Member 'UTngBlackboardData::ObjectList' has a wrong offset!");
static_assert(offsetof(UTngBlackboardData, ClassList) == 0x0000D0, "Member 'UTngBlackboardData::ClassList' has a wrong offset!");
static_assert(offsetof(UTngBlackboardData, EnumList) == 0x000120, "Member 'UTngBlackboardData::EnumList' has a wrong offset!");
static_assert(offsetof(UTngBlackboardData, IntegerList) == 0x000170, "Member 'UTngBlackboardData::IntegerList' has a wrong offset!");
static_assert(offsetof(UTngBlackboardData, BooleanList) == 0x0001C0, "Member 'UTngBlackboardData::BooleanList' has a wrong offset!");
static_assert(offsetof(UTngBlackboardData, StringList) == 0x000210, "Member 'UTngBlackboardData::StringList' has a wrong offset!");
static_assert(offsetof(UTngBlackboardData, NameList) == 0x000260, "Member 'UTngBlackboardData::NameList' has a wrong offset!");
static_assert(offsetof(UTngBlackboardData, VectorList) == 0x0002B0, "Member 'UTngBlackboardData::VectorList' has a wrong offset!");
static_assert(offsetof(UTngBlackboardData, RotatorList) == 0x000300, "Member 'UTngBlackboardData::RotatorList' has a wrong offset!");

// Class TangoLib.TngHUD
// 0x0140 (0x0458 - 0x0318)
class ATngHUD : public AHUD
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                FocusWidget;                                       // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                LayerWidget;                                       // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UTngUserWidget>>     DefaultTngUserWidgets;                             // 0x0330(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UTngUserWidget>>  LayerList;                                         // 0x0340(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UTngUserWidget>, struct FTngWidgetList> AgentList;                                         // 0x0350(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0xB8];                                     // 0x03A0(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowDebugHUD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngHUD">();
	}
	static class ATngHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATngHUD>();
	}
};
static_assert(alignof(ATngHUD) == 0x000008, "Wrong alignment on ATngHUD");
static_assert(sizeof(ATngHUD) == 0x000458, "Wrong size on ATngHUD");
static_assert(offsetof(ATngHUD, FocusWidget) == 0x000320, "Member 'ATngHUD::FocusWidget' has a wrong offset!");
static_assert(offsetof(ATngHUD, LayerWidget) == 0x000328, "Member 'ATngHUD::LayerWidget' has a wrong offset!");
static_assert(offsetof(ATngHUD, DefaultTngUserWidgets) == 0x000330, "Member 'ATngHUD::DefaultTngUserWidgets' has a wrong offset!");
static_assert(offsetof(ATngHUD, LayerList) == 0x000340, "Member 'ATngHUD::LayerList' has a wrong offset!");
static_assert(offsetof(ATngHUD, AgentList) == 0x000350, "Member 'ATngHUD::AgentList' has a wrong offset!");

// Class TangoLib.TngEffectComponent
// 0x0020 (0x0220 - 0x0200)
class UTngEffectComponent final : public USceneComponent
{
public:
	class UTngEffectAsset*                        Effect;                                            // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartActive;                                      // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UParticleSystemComponent> PlayingParticleComponent;                          // 0x0204(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAkComponent>            PlayingAkComponent;                                // 0x020C(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayingAkPlayingID;                                // 0x0214(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyEffect();
	void GenerateParticleEvent(class FName EventName);
	class UTngEffectAsset* GetEffect();
	bool HasCompleted();
	void SetEffect(class UTngEffectAsset* InEffect);
	void SetParticleFloatParameter(class FName ParameterName, float Param);
	void SetParticleLocation(const struct FVector& Location);
	void SetParticleVectorParameter(class FName ParameterName, const struct FVector& Param);
	void StartEffect(int32 ParticleSortPriority);
	void StartEffectAtTransform(class UObject* WorldContextObject, const struct FTransform& Transform, int32 ParticleSortPriority);
	void StartEffectToAttach(class USceneComponent* AttachComponent, const class FName& AttachName, const struct FTransform& OffsetTransform, int32 ParticleSortPriority);
	void StopEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngEffectComponent">();
	}
	static class UTngEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngEffectComponent>();
	}
};
static_assert(alignof(UTngEffectComponent) == 0x000010, "Wrong alignment on UTngEffectComponent");
static_assert(sizeof(UTngEffectComponent) == 0x000220, "Wrong size on UTngEffectComponent");
static_assert(offsetof(UTngEffectComponent, Effect) == 0x0001F8, "Member 'UTngEffectComponent::Effect' has a wrong offset!");
static_assert(offsetof(UTngEffectComponent, bStartActive) == 0x000200, "Member 'UTngEffectComponent::bStartActive' has a wrong offset!");
static_assert(offsetof(UTngEffectComponent, PlayingParticleComponent) == 0x000204, "Member 'UTngEffectComponent::PlayingParticleComponent' has a wrong offset!");
static_assert(offsetof(UTngEffectComponent, PlayingAkComponent) == 0x00020C, "Member 'UTngEffectComponent::PlayingAkComponent' has a wrong offset!");
static_assert(offsetof(UTngEffectComponent, PlayingAkPlayingID) == 0x000214, "Member 'UTngEffectComponent::PlayingAkPlayingID' has a wrong offset!");

// Class TangoLib.TngEquipComponent
// 0x0068 (0x0118 - 0x00B0)
class UTngEquipComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnShouldEquip;                                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBeginEquip;                                      // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndEquip;                                        // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPostSendTags;                                    // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPostChangeSlot;                                  // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTngEquipSlot>                  EquipSlotList;                                     // 0x0100(0x0010)(Edit, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          IsAttachEquip;                                     // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddSlot(class FName SlotName);
	void Blueprint_BeginEquip(const struct FTngEquipSlot& SetSlot);
	void Blueprint_EndEquip(const struct FTngEquipSlot& SetSlot);
	void Blueprint_PostChangeSlot(const struct FTngEquipSlot& SetSlot1, const struct FTngEquipSlot& SetSlot2);
	void Blueprint_PostSendTags(const struct FTngEquipSlot& SetSlot, const struct FGameplayTagContainer& Tags, class UObject* AdvanceParam);
	bool Blueprint_ShouldEquip(const struct FTngEquipSlot& SetSlot, TSubclassOf<class AActor> EquipClass);
	bool ChangeSlotActor(class FName SlotName1, class FName SlotName2);
	bool EquipFromActor(class FName SlotName, class AActor* EquipActor);
	bool EquipFromClass(class FName SlotName, TSubclassOf<class AActor> EquipClass);
	bool EquipFromProperty(class FName SlotName);
	bool EquipFromPropertyAll();
	class AActor* GetEquipActor(class FName SlotName);
	int32 GetIndexFromName(class FName SlotName);
	bool GetSlot(class FName SlotName, struct FTngEquipSlot* OutSlot);
	struct FGameplayTagContainer GetTagsFromSlot(class FName SlotName);
	void NotifyTags(class FName SendSlot, const struct FGameplayTagContainer& SendTags, class UObject* AdvanceObject);
	void RemoveSlot(class FName SlotName);
	bool SendTagsToAll(const struct FGameplayTagContainer& Tags, class UObject* AdvanceParam);
	bool SendTagsToSlot(class FName SlotName, const struct FGameplayTagContainer& Tags, class UObject* AdvanceParam);
	void SetEquipReturnFlag(bool ReturnBool);
	bool UnEquip(class FName SlotName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngEquipComponent">();
	}
	static class UTngEquipComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngEquipComponent>();
	}
};
static_assert(alignof(UTngEquipComponent) == 0x000008, "Wrong alignment on UTngEquipComponent");
static_assert(sizeof(UTngEquipComponent) == 0x000118, "Wrong size on UTngEquipComponent");
static_assert(offsetof(UTngEquipComponent, OnShouldEquip) == 0x0000B0, "Member 'UTngEquipComponent::OnShouldEquip' has a wrong offset!");
static_assert(offsetof(UTngEquipComponent, OnBeginEquip) == 0x0000C0, "Member 'UTngEquipComponent::OnBeginEquip' has a wrong offset!");
static_assert(offsetof(UTngEquipComponent, OnEndEquip) == 0x0000D0, "Member 'UTngEquipComponent::OnEndEquip' has a wrong offset!");
static_assert(offsetof(UTngEquipComponent, OnPostSendTags) == 0x0000E0, "Member 'UTngEquipComponent::OnPostSendTags' has a wrong offset!");
static_assert(offsetof(UTngEquipComponent, OnPostChangeSlot) == 0x0000F0, "Member 'UTngEquipComponent::OnPostChangeSlot' has a wrong offset!");
static_assert(offsetof(UTngEquipComponent, EquipSlotList) == 0x000100, "Member 'UTngEquipComponent::EquipSlotList' has a wrong offset!");
static_assert(offsetof(UTngEquipComponent, IsAttachEquip) == 0x000110, "Member 'UTngEquipComponent::IsAttachEquip' has a wrong offset!");

// Class TangoLib.TngGetInstanceFunction
// 0x0000 (0x0028 - 0x0028)
class UTngGetInstanceFunction final : public UBlueprintFunctionLibrary
{
public:
	static class UTngGameInstance* GetTngGameInstance(const class UObject* WorldContextObject);
	static class ATngPlayerCameraManager* GetTngPlayerCameraManager(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class ATngCharacter* GetTngPlayerCharacter(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class ATngPlayerController* GetTngPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class ATngHUD* GetTngPlayerHud(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class ATngPlayerState* GetTngPlayerState(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class UAnimInstance* K2_GetTngAnimClass(class AActor* Owner, TSubclassOf<class UAnimInstance> ClassType);
	static class USceneComponent* K2_GetTngComponentClassFromAllChild(class USceneComponent* Owner, TSubclassOf<class USceneComponent> ClassType);
	static class USceneComponent* K2_GetTngComponentClassFromAllParent(class USceneComponent* Owner, TSubclassOf<class USceneComponent> ClassType);
	static class UTngGameSystem* K2_GetTngGameSystemClass(class UObject* WorldContextObject, TSubclassOf<class UTngGameSystem> ClassType);
	static class UObject* K2_GetTngObjectDetailInstance(TSubclassOf<class UObject> ClassType);
	static class UObject* K2_GetTngObjectNewInstance(class AActor* Owner, TSubclassOf<class UObject> ClassType);
	static class ATngCharacter* K2_GetTngPlayerCharacterClass(class UObject* WorldContextObject, int32 PlayerIndex, TSubclassOf<class ATngCharacter> ClassType);
	static class ATngPlayerController* K2_GetTngPlayerControllerClass(class UObject* WorldContextObject, int32 PlayerIndex, TSubclassOf<class ATngPlayerController> ClassType);
	static class ATngHUD* K2_GetTngPlayerHudClass(class UObject* WorldContextObject, int32 PlayerIndex, TSubclassOf<class ATngHUD> ClassType);
	static class UTngPlayerService* K2_GetTngPlayerServiceClass(class UObject* WorldContextObject, int32 PlayerIndex, TSubclassOf<class UTngPlayerService> ClassType);
	static class ATngPlayerState* K2_GetTngPlayerStateClass(class UObject* WorldContextObject, int32 PlayerIndex, TSubclassOf<class ATngPlayerState> ClassType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngGetInstanceFunction">();
	}
	static class UTngGetInstanceFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngGetInstanceFunction>();
	}
};
static_assert(alignof(UTngGetInstanceFunction) == 0x000008, "Wrong alignment on UTngGetInstanceFunction");
static_assert(sizeof(UTngGetInstanceFunction) == 0x000028, "Wrong size on UTngGetInstanceFunction");

// Class TangoLib.TngItemObject
// 0x0010 (0x0038 - 0x0028)
class UTngItemObject : public UObject
{
public:
	TArray<class FName>                           Tags;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	bool ItemHasTag(class FName Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngItemObject">();
	}
	static class UTngItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngItemObject>();
	}
};
static_assert(alignof(UTngItemObject) == 0x000008, "Wrong alignment on UTngItemObject");
static_assert(sizeof(UTngItemObject) == 0x000038, "Wrong size on UTngItemObject");
static_assert(offsetof(UTngItemObject, Tags) == 0x000028, "Member 'UTngItemObject::Tags' has a wrong offset!");

// Class TangoLib.TngLocalPlayer
// 0x0188 (0x03E0 - 0x0258)
class UTngLocalPlayer : public ULocalPlayer
{
public:
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         ProfileSaveGameClassName;                          // 0x0260(0x0018)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   DefaultOnlinePresenceText;                         // 0x0278(0x0018)(Config, NativeAccessSpecifierPrivate)
	TSubclassOf<class UTngProfileSaveGame>        ProfileClass;                                      // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTngProfileSaveGame*                    ProfileSaveGame;                                   // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2DDynamic*                      GamerIconTexture;                                  // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x12C];                                    // 0x02A8(0x012C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCheckOnlineUserPrivileges;                        // 0x03D4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D5[0xB];                                      // 0x03D5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanCommunicateOnline() const;
	bool CanPlayMultiplay() const;
	bool IsAgeRestricted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngLocalPlayer">();
	}
	static class UTngLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngLocalPlayer>();
	}
};
static_assert(alignof(UTngLocalPlayer) == 0x000008, "Wrong alignment on UTngLocalPlayer");
static_assert(sizeof(UTngLocalPlayer) == 0x0003E0, "Wrong size on UTngLocalPlayer");
static_assert(offsetof(UTngLocalPlayer, ProfileSaveGameClassName) == 0x000260, "Member 'UTngLocalPlayer::ProfileSaveGameClassName' has a wrong offset!");
static_assert(offsetof(UTngLocalPlayer, DefaultOnlinePresenceText) == 0x000278, "Member 'UTngLocalPlayer::DefaultOnlinePresenceText' has a wrong offset!");
static_assert(offsetof(UTngLocalPlayer, ProfileClass) == 0x000290, "Member 'UTngLocalPlayer::ProfileClass' has a wrong offset!");
static_assert(offsetof(UTngLocalPlayer, ProfileSaveGame) == 0x000298, "Member 'UTngLocalPlayer::ProfileSaveGame' has a wrong offset!");
static_assert(offsetof(UTngLocalPlayer, GamerIconTexture) == 0x0002A0, "Member 'UTngLocalPlayer::GamerIconTexture' has a wrong offset!");
static_assert(offsetof(UTngLocalPlayer, bCheckOnlineUserPrivileges) == 0x0003D4, "Member 'UTngLocalPlayer::bCheckOnlineUserPrivileges' has a wrong offset!");

// Class TangoLib.TngMathFunction
// 0x0000 (0x0028 - 0x0028)
class UTngMathFunction final : public UBlueprintFunctionLibrary
{
public:
	static float Blueprint_DoCountdownFloat(float& NowValue, float DeltaValue, float ResetValue, bool IsAccurately, ETngMathFuncCountdownState* State);
	static void Blueprint_DoCountFloat(float& NowTime, float DeltaTime, float MaxTime, float* NowValue, float MinValue, float MaxValue, EEasingFunc EasingFunc, bool IsCountUp, float Exp, int32 Steps, ETngMathFuncCountState* State);
	static float CalcLoopLength(float NowValue, float TargetValue, float MinValue, float MaxValue);
	static void CalcTngAnalogToRingAngle(float AnalogX, float AnalogY, const float& NowAngle, float* NewAngle, float* Length);
	static float CalcTngClampRingAngle(const float& NowAngle, float Min, float MAX, bool IsLoop);
	static float CalcToValueFromSpeed(float NowValue, float TargetValue, float SpeedValue, float DeltaTime);
	static float CalcToValueFromSpring(float NowValue, float TargetValue, float SpeedValue, float SpringValue, float DumpValue, float DeltaTime);
	static struct FVector CheckScreenLocation(const class UObject* WorldContextObject, const struct FVector& Location);
	static struct FVector ClampBox(const struct FVector& NowValue, const struct FVector& MinValue, const struct FVector& MaxValue, const struct FVector& SizeValue, bool* IsClamp);
	static struct FVector2D ClampCircle(const struct FVector2D& NowValue, const struct FVector2D& MinValue, const struct FVector2D& MaxValue, const struct FVector2D& SizeValue, bool ClampFace, bool* IsClamp, float* OutRotate);
	static float ClampFloat(float NowValue, float MinValue, float MaxValue, float SizeValue, bool* IsClamp);
	static struct FVector ClampSphere(const struct FVector& NowValue, const struct FVector& MinValue, const struct FVector& MaxValue, const struct FVector& SizeValue, bool ClampFace, bool* IsClamp);
	static struct FVector2D ClampSquare(const struct FVector2D& NowValue, const struct FVector2D& MinValue, const struct FVector2D& MaxValue, const struct FVector2D& SizeValue, bool* IsClamp);
	static struct FGameplayTagContainer FilterGameplayTag(const struct FGameplayTagContainer& NowList, const struct FGameplayTagContainer& MaskTags, bool IsExact);
	static bool GetCameraLocationAndRotation(const class UObject* WorldContextObject, struct FVector* Location, struct FRotator* Rotation);
	static struct FGameplayTag GetGameplayTagFromIndex(const struct FGameplayTagContainer& NowList, int32 Index_0);
	static bool IsGameplayTagsValid(const struct FGameplayTagContainer& GameplayTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngMathFunction">();
	}
	static class UTngMathFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngMathFunction>();
	}
};
static_assert(alignof(UTngMathFunction) == 0x000008, "Wrong alignment on UTngMathFunction");
static_assert(sizeof(UTngMathFunction) == 0x000028, "Wrong size on UTngMathFunction");

// Class TangoLib.TngNavLinkCustomComponent
// 0x0000 (0x0190 - 0x0190)
class UTngNavLinkCustomComponent final : public UNavLinkCustomComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngNavLinkCustomComponent">();
	}
	static class UTngNavLinkCustomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngNavLinkCustomComponent>();
	}
};
static_assert(alignof(UTngNavLinkCustomComponent) == 0x000008, "Wrong alignment on UTngNavLinkCustomComponent");
static_assert(sizeof(UTngNavLinkCustomComponent) == 0x000190, "Wrong size on UTngNavLinkCustomComponent");

// Class TangoLib.TngPathFollowingComponent
// 0x00A8 (0x02F8 - 0x0250)
class UTngPathFollowingComponent : public UPathFollowingComponent
{
public:
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTngCharacterMovementComponent*         TngMovementComp;                                   // 0x0258(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetFromCornersDistance;                         // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264[0x15];                                     // 0x0264(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRootMotionNav;                                    // 0x0279(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsRequestedVirtualInputMove;                       // 0x027A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreDriveInputRotation;                         // 0x027B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x24];                                     // 0x0288(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bApplyFlyingImpulse;                               // 0x02AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AD[0x4B];                                     // 0x02AD(0x004B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPathFindFilter(TSubclassOf<class UNavigationQueryFilter> NewFilter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngPathFollowingComponent">();
	}
	static class UTngPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngPathFollowingComponent>();
	}
};
static_assert(alignof(UTngPathFollowingComponent) == 0x000008, "Wrong alignment on UTngPathFollowingComponent");
static_assert(sizeof(UTngPathFollowingComponent) == 0x0002F8, "Wrong size on UTngPathFollowingComponent");
static_assert(offsetof(UTngPathFollowingComponent, TngMovementComp) == 0x000258, "Member 'UTngPathFollowingComponent::TngMovementComp' has a wrong offset!");
static_assert(offsetof(UTngPathFollowingComponent, OffsetFromCornersDistance) == 0x000260, "Member 'UTngPathFollowingComponent::OffsetFromCornersDistance' has a wrong offset!");
static_assert(offsetof(UTngPathFollowingComponent, bRootMotionNav) == 0x000279, "Member 'UTngPathFollowingComponent::bRootMotionNav' has a wrong offset!");
static_assert(offsetof(UTngPathFollowingComponent, IsRequestedVirtualInputMove) == 0x00027A, "Member 'UTngPathFollowingComponent::IsRequestedVirtualInputMove' has a wrong offset!");
static_assert(offsetof(UTngPathFollowingComponent, bIgnoreDriveInputRotation) == 0x00027B, "Member 'UTngPathFollowingComponent::bIgnoreDriveInputRotation' has a wrong offset!");
static_assert(offsetof(UTngPathFollowingComponent, FilterClass) == 0x000280, "Member 'UTngPathFollowingComponent::FilterClass' has a wrong offset!");
static_assert(offsetof(UTngPathFollowingComponent, bApplyFlyingImpulse) == 0x0002AC, "Member 'UTngPathFollowingComponent::bApplyFlyingImpulse' has a wrong offset!");

// Class TangoLib.TngPlayerController
// 0x0050 (0x05D8 - 0x0588)
class ATngPlayerController : public APlayerController
{
public:
	TArray<class UTngPlayerService*>              PlayerServiceList;                                 // 0x0588(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UTngPlayerService>>  DefaultPlayerService;                              // 0x0598(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UTngPlayerService>>  DebugPlayerService;                                // 0x05A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UPlayerInput>               PlayerInputClass;                                  // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x18];                                     // 0x05C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTngPlayerService* GetPlayerServiceClass(TSubclassOf<class UTngPlayerService> ClassType);
	void PlayTngControllerShake(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag);
	void TeleportPlayer(const struct FVector& PlayerLocaltion, const struct FRotator& CameraRotation);

	bool CheckGamePadMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngPlayerController">();
	}
	static class ATngPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATngPlayerController>();
	}
};
static_assert(alignof(ATngPlayerController) == 0x000008, "Wrong alignment on ATngPlayerController");
static_assert(sizeof(ATngPlayerController) == 0x0005D8, "Wrong size on ATngPlayerController");
static_assert(offsetof(ATngPlayerController, PlayerServiceList) == 0x000588, "Member 'ATngPlayerController::PlayerServiceList' has a wrong offset!");
static_assert(offsetof(ATngPlayerController, DefaultPlayerService) == 0x000598, "Member 'ATngPlayerController::DefaultPlayerService' has a wrong offset!");
static_assert(offsetof(ATngPlayerController, DebugPlayerService) == 0x0005A8, "Member 'ATngPlayerController::DebugPlayerService' has a wrong offset!");
static_assert(offsetof(ATngPlayerController, PlayerInputClass) == 0x0005B8, "Member 'ATngPlayerController::PlayerInputClass' has a wrong offset!");

// Class TangoLib.TngPlayerInput
// 0x0000 (0x03A8 - 0x03A8)
class UTngPlayerInput final : public UPlayerInput
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngPlayerInput">();
	}
	static class UTngPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngPlayerInput>();
	}
};
static_assert(alignof(UTngPlayerInput) == 0x000008, "Wrong alignment on UTngPlayerInput");
static_assert(sizeof(UTngPlayerInput) == 0x0003A8, "Wrong size on UTngPlayerInput");

// Class TangoLib.TngPlayerInputSettings
// 0x0070 (0x0098 - 0x0028)
class UTngPlayerInputSettings final : public UObject
{
public:
	TMap<class FName, struct FTngPlayerInputKeyMappingsSet> CustomKeyMappingsSets;                             // 0x0028(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<struct FTngPlayerInputKeyRemapping>    AzertyKeyRemapings;                                // 0x0078(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FTngPlayerInputKeyRemapping>    QwertzKeyRemapings;                                // 0x0088(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngPlayerInputSettings">();
	}
	static class UTngPlayerInputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngPlayerInputSettings>();
	}
};
static_assert(alignof(UTngPlayerInputSettings) == 0x000008, "Wrong alignment on UTngPlayerInputSettings");
static_assert(sizeof(UTngPlayerInputSettings) == 0x000098, "Wrong size on UTngPlayerInputSettings");
static_assert(offsetof(UTngPlayerInputSettings, CustomKeyMappingsSets) == 0x000028, "Member 'UTngPlayerInputSettings::CustomKeyMappingsSets' has a wrong offset!");
static_assert(offsetof(UTngPlayerInputSettings, AzertyKeyRemapings) == 0x000078, "Member 'UTngPlayerInputSettings::AzertyKeyRemapings' has a wrong offset!");
static_assert(offsetof(UTngPlayerInputSettings, QwertzKeyRemapings) == 0x000088, "Member 'UTngPlayerInputSettings::QwertzKeyRemapings' has a wrong offset!");

// Class TangoLib.TngPlayerInputUserSettings
// 0x0048 (0x0070 - 0x0028)
class UTngPlayerInputUserSettings final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInputActionKeyMapping>         KeyboardMouseInputActionKeyMappings;               // 0x0048(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FInputAxisKeyMapping>           KeyboardMouseInputAxisKeyMappings;                 // 0x0058(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         CustomKeyMappingBuildVersion;                      // 0x0068(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngPlayerInputUserSettings">();
	}
	static class UTngPlayerInputUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngPlayerInputUserSettings>();
	}
};
static_assert(alignof(UTngPlayerInputUserSettings) == 0x000008, "Wrong alignment on UTngPlayerInputUserSettings");
static_assert(sizeof(UTngPlayerInputUserSettings) == 0x000070, "Wrong size on UTngPlayerInputUserSettings");
static_assert(offsetof(UTngPlayerInputUserSettings, KeyboardMouseInputActionKeyMappings) == 0x000048, "Member 'UTngPlayerInputUserSettings::KeyboardMouseInputActionKeyMappings' has a wrong offset!");
static_assert(offsetof(UTngPlayerInputUserSettings, KeyboardMouseInputAxisKeyMappings) == 0x000058, "Member 'UTngPlayerInputUserSettings::KeyboardMouseInputAxisKeyMappings' has a wrong offset!");
static_assert(offsetof(UTngPlayerInputUserSettings, CustomKeyMappingBuildVersion) == 0x000068, "Member 'UTngPlayerInputUserSettings::CustomKeyMappingBuildVersion' has a wrong offset!");

// Class TangoLib.TngPlayerMetrics
// 0x01F8 (0x0220 - 0x0028)
class UTngPlayerMetrics : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      StatValues;                                        // 0x0058(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      GameChallengeProgreessValues;                      // 0x00A8(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x118];                                     // 0x00F8(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	class UTngPlayerMetricsSettings*              MetricsSettings;                                   // 0x0210(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ModifyStat(const class FName& StatName, int32 Value, ETngPlayerMetricsStatModifier Modifier);
	bool ModifyStat_Decrement(const class FName& StatName);
	bool ModifyStat_Increment(const class FName& StatName);

	int32 GetStatValueOnGame(const class FName& StatName) const;
	int32 GetStatValueOnProfile(const class FName& StatName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngPlayerMetrics">();
	}
	static class UTngPlayerMetrics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngPlayerMetrics>();
	}
};
static_assert(alignof(UTngPlayerMetrics) == 0x000008, "Wrong alignment on UTngPlayerMetrics");
static_assert(sizeof(UTngPlayerMetrics) == 0x000220, "Wrong size on UTngPlayerMetrics");
static_assert(offsetof(UTngPlayerMetrics, StatValues) == 0x000058, "Member 'UTngPlayerMetrics::StatValues' has a wrong offset!");
static_assert(offsetof(UTngPlayerMetrics, GameChallengeProgreessValues) == 0x0000A8, "Member 'UTngPlayerMetrics::GameChallengeProgreessValues' has a wrong offset!");
static_assert(offsetof(UTngPlayerMetrics, MetricsSettings) == 0x000210, "Member 'UTngPlayerMetrics::MetricsSettings' has a wrong offset!");

// Class TangoLib.TngPlayerMetricsSettings
// 0x0050 (0x0078 - 0x0028)
class UTngPlayerMetricsSettings final : public UObject
{
public:
	TArray<struct FTngPlayerStatEntry>            StatEntries;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTngPlayerStatExtensionPS5Entry> StatPS5ExtensionEntries;                           // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTngPlayerStatExtensionGDKEntry> StatGDKExtensionEntries;                           // 0x0048(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTngAchievementEntry>           AchievementEntries;                                // 0x0058(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTngGameChallengeEntry>         GameChallengeEntries;                              // 0x0068(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngPlayerMetricsSettings">();
	}
	static class UTngPlayerMetricsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngPlayerMetricsSettings>();
	}
};
static_assert(alignof(UTngPlayerMetricsSettings) == 0x000008, "Wrong alignment on UTngPlayerMetricsSettings");
static_assert(sizeof(UTngPlayerMetricsSettings) == 0x000078, "Wrong size on UTngPlayerMetricsSettings");
static_assert(offsetof(UTngPlayerMetricsSettings, StatEntries) == 0x000028, "Member 'UTngPlayerMetricsSettings::StatEntries' has a wrong offset!");
static_assert(offsetof(UTngPlayerMetricsSettings, StatPS5ExtensionEntries) == 0x000038, "Member 'UTngPlayerMetricsSettings::StatPS5ExtensionEntries' has a wrong offset!");
static_assert(offsetof(UTngPlayerMetricsSettings, StatGDKExtensionEntries) == 0x000048, "Member 'UTngPlayerMetricsSettings::StatGDKExtensionEntries' has a wrong offset!");
static_assert(offsetof(UTngPlayerMetricsSettings, AchievementEntries) == 0x000058, "Member 'UTngPlayerMetricsSettings::AchievementEntries' has a wrong offset!");
static_assert(offsetof(UTngPlayerMetricsSettings, GameChallengeEntries) == 0x000068, "Member 'UTngPlayerMetricsSettings::GameChallengeEntries' has a wrong offset!");

// Class TangoLib.TngPlayerState
// 0x0010 (0x0338 - 0x0328)
class ATngPlayerState : public APlayerState
{
public:
	TSubclassOf<class UTngPlayerMetrics>          MetricsClass;                                      // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTngPlayerMetrics*                      Metrics;                                           // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ModifyStat(class FName Key, int32 Ammo, ETngPlayerMetricsStatModifier Modifier);

	int32 GetStatValueOnGame(class FName Key) const;
	int32 GetStatValueOnProfile(class FName Key) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngPlayerState">();
	}
	static class ATngPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATngPlayerState>();
	}
};
static_assert(alignof(ATngPlayerState) == 0x000008, "Wrong alignment on ATngPlayerState");
static_assert(sizeof(ATngPlayerState) == 0x000338, "Wrong size on ATngPlayerState");
static_assert(offsetof(ATngPlayerState, MetricsClass) == 0x000328, "Member 'ATngPlayerState::MetricsClass' has a wrong offset!");
static_assert(offsetof(ATngPlayerState, Metrics) == 0x000330, "Member 'ATngPlayerState::Metrics' has a wrong offset!");

// Class TangoLib.TngProfileSaveGame
// 0x00A8 (0x00D0 - 0x0028)
class UTngProfileSaveGame : public UObject
{
public:
	TMap<class FName, int32>                      StatValues;                                        // 0x0028(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTngInputActionKeyMappingSaveGame> GamepadActionKeyMappings;                          // 0x0078(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTngInputAxisKeyMappingSaveGame> GamepadAxisKeyMappings;                            // 0x0088(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTngInputActionKeyMappingSaveGame> KeyboardMouseActionKeyMappings;                    // 0x0098(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTngInputAxisKeyMappingSaveGame> KeyboardMouseAxisKeyMappings;                      // 0x00A8(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	int32                                         GamepadKeyMappingVersion;                          // 0x00B8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTngPlayerInputUserSettings*            InputUserSettings;                                 // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGameUserSettings* GetUserSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngProfileSaveGame">();
	}
	static class UTngProfileSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngProfileSaveGame>();
	}
};
static_assert(alignof(UTngProfileSaveGame) == 0x000008, "Wrong alignment on UTngProfileSaveGame");
static_assert(sizeof(UTngProfileSaveGame) == 0x0000D0, "Wrong size on UTngProfileSaveGame");
static_assert(offsetof(UTngProfileSaveGame, StatValues) == 0x000028, "Member 'UTngProfileSaveGame::StatValues' has a wrong offset!");
static_assert(offsetof(UTngProfileSaveGame, GamepadActionKeyMappings) == 0x000078, "Member 'UTngProfileSaveGame::GamepadActionKeyMappings' has a wrong offset!");
static_assert(offsetof(UTngProfileSaveGame, GamepadAxisKeyMappings) == 0x000088, "Member 'UTngProfileSaveGame::GamepadAxisKeyMappings' has a wrong offset!");
static_assert(offsetof(UTngProfileSaveGame, KeyboardMouseActionKeyMappings) == 0x000098, "Member 'UTngProfileSaveGame::KeyboardMouseActionKeyMappings' has a wrong offset!");
static_assert(offsetof(UTngProfileSaveGame, KeyboardMouseAxisKeyMappings) == 0x0000A8, "Member 'UTngProfileSaveGame::KeyboardMouseAxisKeyMappings' has a wrong offset!");
static_assert(offsetof(UTngProfileSaveGame, GamepadKeyMappingVersion) == 0x0000B8, "Member 'UTngProfileSaveGame::GamepadKeyMappingVersion' has a wrong offset!");
static_assert(offsetof(UTngProfileSaveGame, InputUserSettings) == 0x0000C0, "Member 'UTngProfileSaveGame::InputUserSettings' has a wrong offset!");

// Class TangoLib.TngRandomPick
// 0x0000 (0x0028 - 0x0028)
class UTngRandomPick final : public UBlueprintFunctionLibrary
{
public:
	static int32 RandomPick(const TArray<struct FTngRandomPickWeight>& ItemArray);
	static int32 RandomPickActor(const TArray<struct FTngRandomPickWeightWithActor>& ItemArray, class AActor** PickedData);
	static int32 RandomPickFloat(const TArray<struct FTngRandomPickWeightWithFloat>& ItemArray, float* PickedData);
	static int32 RandomPickInteger(const TArray<struct FTngRandomPickWeightWithInteger>& ItemArray, int32* PickedData);
	static int32 RandomPickVector(const TArray<struct FTngRandomPickWeightWithVector>& ItemArray, struct FVector* PickedData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngRandomPick">();
	}
	static class UTngRandomPick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngRandomPick>();
	}
};
static_assert(alignof(UTngRandomPick) == 0x000008, "Wrong alignment on UTngRandomPick");
static_assert(sizeof(UTngRandomPick) == 0x000028, "Wrong size on UTngRandomPick");

// Class TangoLib.TngSaveGameDetail
// 0x0020 (0x0048 - 0x0028)
class UTngSaveGameDetail : public UObject
{
public:
	class FString                                 SlotName;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              DateTime;                                          // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BuildVersion;                                      // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCorrupted;                                        // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUnsupportedOlderVersion;                          // 0x0045(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIncompatibleNewerVersion;                         // 0x0046(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngSaveGameDetail">();
	}
	static class UTngSaveGameDetail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngSaveGameDetail>();
	}
};
static_assert(alignof(UTngSaveGameDetail) == 0x000008, "Wrong alignment on UTngSaveGameDetail");
static_assert(sizeof(UTngSaveGameDetail) == 0x000048, "Wrong size on UTngSaveGameDetail");
static_assert(offsetof(UTngSaveGameDetail, SlotName) == 0x000028, "Member 'UTngSaveGameDetail::SlotName' has a wrong offset!");
static_assert(offsetof(UTngSaveGameDetail, DateTime) == 0x000038, "Member 'UTngSaveGameDetail::DateTime' has a wrong offset!");
static_assert(offsetof(UTngSaveGameDetail, BuildVersion) == 0x000040, "Member 'UTngSaveGameDetail::BuildVersion' has a wrong offset!");
static_assert(offsetof(UTngSaveGameDetail, bCorrupted) == 0x000044, "Member 'UTngSaveGameDetail::bCorrupted' has a wrong offset!");
static_assert(offsetof(UTngSaveGameDetail, bUnsupportedOlderVersion) == 0x000045, "Member 'UTngSaveGameDetail::bUnsupportedOlderVersion' has a wrong offset!");
static_assert(offsetof(UTngSaveGameDetail, bIncompatibleNewerVersion) == 0x000046, "Member 'UTngSaveGameDetail::bIncompatibleNewerVersion' has a wrong offset!");

// Class TangoLib.TngSaveGameManager
// 0x00C8 (0x0100 - 0x0038)
class UTngSaveGameManager : public UTngGameSystem
{
public:
	uint8                                         Pad_38[0x60];                                      // 0x0038(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         DetailClassName;                                   // 0x0098(0x0018)(Edit, ZeroConstructor, Config, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTngSaveGameDetail>         DetailClass;                                       // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTngSaveGameDetail*>             CachedDetails;                                     // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x38];                                      // 0x00C8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngSaveGameManager">();
	}
	static class UTngSaveGameManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngSaveGameManager>();
	}
};
static_assert(alignof(UTngSaveGameManager) == 0x000008, "Wrong alignment on UTngSaveGameManager");
static_assert(sizeof(UTngSaveGameManager) == 0x000100, "Wrong size on UTngSaveGameManager");
static_assert(offsetof(UTngSaveGameManager, DetailClassName) == 0x000098, "Member 'UTngSaveGameManager::DetailClassName' has a wrong offset!");
static_assert(offsetof(UTngSaveGameManager, DetailClass) == 0x0000B0, "Member 'UTngSaveGameManager::DetailClass' has a wrong offset!");
static_assert(offsetof(UTngSaveGameManager, CachedDetails) == 0x0000B8, "Member 'UTngSaveGameManager::CachedDetails' has a wrong offset!");

// Class TangoLib.TngSpectatorPawn
// 0x0010 (0x02C0 - 0x02B0)
class ATngSpectatorPawn final : public ASpectatorPawn
{
public:
	uint8                                         Pad_2B0[0x4];                                      // 0x02B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveSpeed;                                         // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeed;                                       // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngSpectatorPawn">();
	}
	static class ATngSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATngSpectatorPawn>();
	}
};
static_assert(alignof(ATngSpectatorPawn) == 0x000008, "Wrong alignment on ATngSpectatorPawn");
static_assert(sizeof(ATngSpectatorPawn) == 0x0002C0, "Wrong size on ATngSpectatorPawn");
static_assert(offsetof(ATngSpectatorPawn, MoveSpeed) == 0x0002B4, "Member 'ATngSpectatorPawn::MoveSpeed' has a wrong offset!");
static_assert(offsetof(ATngSpectatorPawn, RotateSpeed) == 0x0002B8, "Member 'ATngSpectatorPawn::RotateSpeed' has a wrong offset!");

// Class TangoLib.TngSplineComponent
// 0x0000 (0x0550 - 0x0550)
class UTngSplineComponent final : public USplineComponent
{
public:
	float                                         BaseSplineRadius;                                  // 0x0548(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDistanceAlongSplineAtInputKey(float InputKey) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngSplineComponent">();
	}
	static class UTngSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngSplineComponent>();
	}
};
static_assert(alignof(UTngSplineComponent) == 0x000010, "Wrong alignment on UTngSplineComponent");
static_assert(sizeof(UTngSplineComponent) == 0x000550, "Wrong size on UTngSplineComponent");
static_assert(offsetof(UTngSplineComponent, BaseSplineRadius) == 0x000548, "Member 'UTngSplineComponent::BaseSplineRadius' has a wrong offset!");

// Class TangoLib.TngSplineDrawingComponent
// 0x0020 (0x0470 - 0x0450)
class UTngSplineDrawingComponent final : public UPrimitiveComponent
{
public:
	struct FLinearColor                           LineColor;                                         // 0x0450(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LineThickness;                                     // 0x0460(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LineOffsetHeight;                                  // 0x0464(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHiddenWhenSelected;                               // 0x0468(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVisibleWidth;                                     // 0x0469(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46A[0x6];                                      // 0x046A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateDrawSpline();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngSplineDrawingComponent">();
	}
	static class UTngSplineDrawingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngSplineDrawingComponent>();
	}
};
static_assert(alignof(UTngSplineDrawingComponent) == 0x000010, "Wrong alignment on UTngSplineDrawingComponent");
static_assert(sizeof(UTngSplineDrawingComponent) == 0x000470, "Wrong size on UTngSplineDrawingComponent");
static_assert(offsetof(UTngSplineDrawingComponent, LineColor) == 0x000450, "Member 'UTngSplineDrawingComponent::LineColor' has a wrong offset!");
static_assert(offsetof(UTngSplineDrawingComponent, LineThickness) == 0x000460, "Member 'UTngSplineDrawingComponent::LineThickness' has a wrong offset!");
static_assert(offsetof(UTngSplineDrawingComponent, LineOffsetHeight) == 0x000464, "Member 'UTngSplineDrawingComponent::LineOffsetHeight' has a wrong offset!");
static_assert(offsetof(UTngSplineDrawingComponent, bHiddenWhenSelected) == 0x000468, "Member 'UTngSplineDrawingComponent::bHiddenWhenSelected' has a wrong offset!");
static_assert(offsetof(UTngSplineDrawingComponent, bVisibleWidth) == 0x000469, "Member 'UTngSplineDrawingComponent::bVisibleWidth' has a wrong offset!");

// Class TangoLib.TngSplineFollowingInterface
// 0x0000 (0x0028 - 0x0028)
class ITngSplineFollowingInterface final : public IInterface
{
public:
	bool BlueprintNative_AbortToMoveOnSplineByThrottle();
	bool BlueprintNative_ChangeThrottleOfSplineFollowing(float Throttle, bool IsDelta);
	bool BlueprintNative_MoveOnSplineBySpeed(class USplineComponent* Spline, float MaxSpeed, float Accel, ETngSplineFollowingBehavior BehaviorType);
	bool BlueprintNative_MoveOnSplineByThrottle(class USplineComponent* Spline, float Throttle, ETngSplineFollowingBehavior BehaviorType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngSplineFollowingInterface">();
	}
	static class ITngSplineFollowingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITngSplineFollowingInterface>();
	}
};
static_assert(alignof(ITngSplineFollowingInterface) == 0x000008, "Wrong alignment on ITngSplineFollowingInterface");
static_assert(sizeof(ITngSplineFollowingInterface) == 0x000028, "Wrong size on ITngSplineFollowingInterface");

// Class TangoLib.TngSplineMovementComponent
// 0x00B0 (0x01A0 - 0x00F0)
class alignas(0x10) UTngSplineMovementComponent final : public UMovementComponent
{
public:
	TSoftObjectPtr<class AActor>                  IniSplineActor;                                    // 0x00F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IniMoverSpeed;                                     // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IniMoverMaxSpeed;                                  // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IniMoverAccel;                                     // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x8];                                      // 0x0124(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MoverOffsetLocation;                               // 0x012C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               MoverOffsetRotation;                               // 0x0138(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	ETngSplineFollowingBehavior                   MoverBehaviorType;                                 // 0x0144(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETngSplineMovementSteeringType                MoverSteeringType;                                 // 0x0145(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_146[0x4E];                                     // 0x0146(0x004E)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SteeringRate;                                      // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAutoMoverStart : 1;                               // 0x0198(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Receive_OnChangeStateExtraAnim(ETngExtraPlayState NewState);
	bool StartMovement(class USplineComponent* TargetSpline, float MaxSpeed, float Acceleration, float InitialSpeed);
	bool StartMovementByThrottle(class USplineComponent* TargetSpline, float Throttle, ETngSplineFollowingBehavior BehaviorType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngSplineMovementComponent">();
	}
	static class UTngSplineMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngSplineMovementComponent>();
	}
};
static_assert(alignof(UTngSplineMovementComponent) == 0x000010, "Wrong alignment on UTngSplineMovementComponent");
static_assert(sizeof(UTngSplineMovementComponent) == 0x0001A0, "Wrong size on UTngSplineMovementComponent");
static_assert(offsetof(UTngSplineMovementComponent, IniSplineActor) == 0x0000F0, "Member 'UTngSplineMovementComponent::IniSplineActor' has a wrong offset!");
static_assert(offsetof(UTngSplineMovementComponent, IniMoverSpeed) == 0x000118, "Member 'UTngSplineMovementComponent::IniMoverSpeed' has a wrong offset!");
static_assert(offsetof(UTngSplineMovementComponent, IniMoverMaxSpeed) == 0x00011C, "Member 'UTngSplineMovementComponent::IniMoverMaxSpeed' has a wrong offset!");
static_assert(offsetof(UTngSplineMovementComponent, IniMoverAccel) == 0x000120, "Member 'UTngSplineMovementComponent::IniMoverAccel' has a wrong offset!");
static_assert(offsetof(UTngSplineMovementComponent, MoverOffsetLocation) == 0x00012C, "Member 'UTngSplineMovementComponent::MoverOffsetLocation' has a wrong offset!");
static_assert(offsetof(UTngSplineMovementComponent, MoverOffsetRotation) == 0x000138, "Member 'UTngSplineMovementComponent::MoverOffsetRotation' has a wrong offset!");
static_assert(offsetof(UTngSplineMovementComponent, MoverBehaviorType) == 0x000144, "Member 'UTngSplineMovementComponent::MoverBehaviorType' has a wrong offset!");
static_assert(offsetof(UTngSplineMovementComponent, MoverSteeringType) == 0x000145, "Member 'UTngSplineMovementComponent::MoverSteeringType' has a wrong offset!");
static_assert(offsetof(UTngSplineMovementComponent, SteeringRate) == 0x000194, "Member 'UTngSplineMovementComponent::SteeringRate' has a wrong offset!");

// Class TangoLib.TngStateCoordinateComponent
// 0x0060 (0x0110 - 0x00B0)
class UTngStateCoordinateComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnChangeState;                                     // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTngStateSlot>                  SlotList;                                          // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FTngStateSlot                          PassiveSlot;                                       // 0x00D0(0x0030)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTngStateItem* Blueprint_AddState(class FName SlotName, TSubclassOf<class UTngStateItem> ClassType);
	class UTngStateItem* Blueprint_GetState(class FName SlotName, TSubclassOf<class UTngStateItem> ClassType);
	class UTngStateItem* Blueprint_GetStateFromAllSlot(TSubclassOf<class UTngStateItem> ClassType);
	class FName GetCurrentStateName(class FName SlotName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngStateCoordinateComponent">();
	}
	static class UTngStateCoordinateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngStateCoordinateComponent>();
	}
};
static_assert(alignof(UTngStateCoordinateComponent) == 0x000008, "Wrong alignment on UTngStateCoordinateComponent");
static_assert(sizeof(UTngStateCoordinateComponent) == 0x000110, "Wrong size on UTngStateCoordinateComponent");
static_assert(offsetof(UTngStateCoordinateComponent, OnChangeState) == 0x0000B0, "Member 'UTngStateCoordinateComponent::OnChangeState' has a wrong offset!");
static_assert(offsetof(UTngStateCoordinateComponent, SlotList) == 0x0000C0, "Member 'UTngStateCoordinateComponent::SlotList' has a wrong offset!");
static_assert(offsetof(UTngStateCoordinateComponent, PassiveSlot) == 0x0000D0, "Member 'UTngStateCoordinateComponent::PassiveSlot' has a wrong offset!");

// Class TangoLib.TngUserWidget
// 0x0080 (0x02E0 - 0x0260)
class UTngUserWidget : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnTngEnable_BP;                                    // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTngDisable_BP;                                   // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTngBeginOver_BP;                                 // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTngEndOver_BP;                                   // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTngRemoveWidget_BP;                              // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         RegisterLayer;                                     // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x18];                                     // 0x02C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FEventReply Blueprint_OnInputAxisResult(ETngKeyAxisMap Axis, ETngKeyState KeyState, float Value, const struct FAnalogInputEvent& AnalogEvent);
	struct FEventReply Blueprint_OnInputButtonResult(ETngKeyButtonMap Button, ETngKeyState KeyState, const struct FKeyEvent& KeyEvent);
	void Blueprint_OnTngBeginOver();
	void Blueprint_OnTngDisable();
	void Blueprint_OnTngEnable();
	void Blueprint_OnTngEndOver();
	void Blueprint_OnTngRemoveWidget();
	bool DisablePlayerInput(class APlayerController* PlayerController);
	bool EnablePlayerInput(class APlayerController* PlayerController);
	void FinishTngUserWidget();
	void PostChangeParam();
	bool SetAudioPauseWithWidget(class APlayerController* PlayerController, bool bPause);
	bool SetGamePauseWithWidget(class APlayerController* PlayerController, bool bPause);

	bool IsConsoleMachine() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngUserWidget">();
	}
	static class UTngUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngUserWidget>();
	}
};
static_assert(alignof(UTngUserWidget) == 0x000008, "Wrong alignment on UTngUserWidget");
static_assert(sizeof(UTngUserWidget) == 0x0002E0, "Wrong size on UTngUserWidget");
static_assert(offsetof(UTngUserWidget, OnTngEnable_BP) == 0x000260, "Member 'UTngUserWidget::OnTngEnable_BP' has a wrong offset!");
static_assert(offsetof(UTngUserWidget, OnTngDisable_BP) == 0x000270, "Member 'UTngUserWidget::OnTngDisable_BP' has a wrong offset!");
static_assert(offsetof(UTngUserWidget, OnTngBeginOver_BP) == 0x000280, "Member 'UTngUserWidget::OnTngBeginOver_BP' has a wrong offset!");
static_assert(offsetof(UTngUserWidget, OnTngEndOver_BP) == 0x000290, "Member 'UTngUserWidget::OnTngEndOver_BP' has a wrong offset!");
static_assert(offsetof(UTngUserWidget, OnTngRemoveWidget_BP) == 0x0002A0, "Member 'UTngUserWidget::OnTngRemoveWidget_BP' has a wrong offset!");
static_assert(offsetof(UTngUserWidget, RegisterLayer) == 0x0002B0, "Member 'UTngUserWidget::RegisterLayer' has a wrong offset!");
static_assert(offsetof(UTngUserWidget, Tags) == 0x0002B8, "Member 'UTngUserWidget::Tags' has a wrong offset!");

// Class TangoLib.TngVitalComponent
// 0x00D8 (0x0188 - 0x00B0)
class UTngVitalComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnActorDied;                                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOwnerDied;                                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangedValue;                                    // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBecomedZero;                                     // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTakeAnyVitalDamage;                              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAutoRecoveryValue;                               // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UTngVitalElementBase*>           VitalElements;                                     // 0x0110(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x64];                                     // 0x0120(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bGenerateAutoRecoveryEvent : 1;                    // 0x0184(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsDead : 1;                                       // 0x0184(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsGod : 1;                                        // 0x0184(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float AddHealth(float AddValue);
	void AddVitalValue(const struct FGameplayTag& Tag, float AddValue);
	float AddVitalValueByIndex(int32 Index_0, float AddValue);
	void EnableVitalAutoRecovery(const struct FGameplayTag& Tag, bool Enable);
	void EnableVitalAutoRecoveryByIndex(int32 Index_0, bool Enable);
	void ModifyActualVitalDamage(float NewDamageAmount);
	void NotifyAnyTakeDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
	void NotifyVitalValueChanged(class UTngVitalElementBase* VitalElementPtr, float Value, float PrevValue, float ValueRate, ETngVitalChangedReason Reason);
	void ProtectVitalValue(const struct FGameplayTag& Tag, bool Enable);
	void ProtectVitalValueByIndex(int32 Index_0, bool Enable);
	float ResetHealth();
	void ResetVitalAll();
	float ResetVitalValue(const struct FGameplayTag& Tag);
	float ResetVitalValueByIndex(int32 Index_0);
	bool SetHealth(float NewHealth);
	bool SetMaxHealth(float NewMaxHealth);
	bool SetMaxVitalValue(const struct FGameplayTag& Tag, float NewMaxHealth);
	bool SetMaxVitalValueByIndex(int32 Index_0, float NewMaxValue);
	void SetVitalAutoRecovery(const struct FGameplayTag& Tag, float NewAutoRecoveryPerSec);
	void SetVitalAutoRecoveryByIndex(int32 Index_0, float NewAutoRecoveryPerSec);
	bool SetVitalValue(const struct FGameplayTag& Tag, float NewHealth);
	bool SetVitalValueByIndex(int32 Index_0, float NewValue);

	float GetHealth() const;
	float GetHealthRate() const;
	float GetMaxHealth() const;
	float GetMaxVitalValue(const struct FGameplayTag& Tag) const;
	float GetMaxVitalValueByIndex(int32 Index_0) const;
	class UTngVitalElementBase* GetVitalElement(const struct FGameplayTag& Tag) const;
	class UTngVitalElementBase* GetVitalElementByIndex(int32 Index_0) const;
	int32 GetVitalIndexByTag(const struct FGameplayTag& Tag) const;
	float GetVitalRate(const struct FGameplayTag& Tag) const;
	float GetVitalRateByIndex(int32 Index_0) const;
	float GetVitalValue(const struct FGameplayTag& Tag) const;
	float GetVitalValueByIndex(int32 Index_0) const;
	bool IsDead() const;
	bool IsProtection(const struct FGameplayTag& Tag) const;
	bool IsProtectionByIndex(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngVitalComponent">();
	}
	static class UTngVitalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngVitalComponent>();
	}
};
static_assert(alignof(UTngVitalComponent) == 0x000008, "Wrong alignment on UTngVitalComponent");
static_assert(sizeof(UTngVitalComponent) == 0x000188, "Wrong size on UTngVitalComponent");
static_assert(offsetof(UTngVitalComponent, OnActorDied) == 0x0000B0, "Member 'UTngVitalComponent::OnActorDied' has a wrong offset!");
static_assert(offsetof(UTngVitalComponent, OnOwnerDied) == 0x0000C0, "Member 'UTngVitalComponent::OnOwnerDied' has a wrong offset!");
static_assert(offsetof(UTngVitalComponent, OnChangedValue) == 0x0000D0, "Member 'UTngVitalComponent::OnChangedValue' has a wrong offset!");
static_assert(offsetof(UTngVitalComponent, OnBecomedZero) == 0x0000E0, "Member 'UTngVitalComponent::OnBecomedZero' has a wrong offset!");
static_assert(offsetof(UTngVitalComponent, OnTakeAnyVitalDamage) == 0x0000F0, "Member 'UTngVitalComponent::OnTakeAnyVitalDamage' has a wrong offset!");
static_assert(offsetof(UTngVitalComponent, OnAutoRecoveryValue) == 0x000100, "Member 'UTngVitalComponent::OnAutoRecoveryValue' has a wrong offset!");
static_assert(offsetof(UTngVitalComponent, VitalElements) == 0x000110, "Member 'UTngVitalComponent::VitalElements' has a wrong offset!");

// Class TangoLib.TngVitalElementBase
// 0x0030 (0x0058 - 0x0028)
class UTngVitalElementBase final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintAuthorityOnly, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           VitalTag;                                          // 0x0040(0x0008)(Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           DamageVitalTag;                                    // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoRecoveryPerSec;                                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsZeroDeath : 1;                                  // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_54_1 : 1;                                   // 0x0054(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsProtect : 1;                                    // 0x0054(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableAutoRecovery : 1;                           // 0x0054(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float AddVitalValue(float AddValue, ETngVitalChangedReason Reason);
	float BlueprintNative_CalcDamageAmount(float Damage, bool IsRecovery);
	bool BlueprintNative_CanActivate();
	float BlueprintNative_GetResetVitalValue();
	void EnableVitalAutoRecovery(bool Enable);
	bool MatchDamageVitalTag(const struct FGameplayTagContainer& DestTagContainer);
	bool MatchVitalTag(const struct FGameplayTag& TestTag);
	void ProtectVitalValue(bool Enable);
	float ResetVitalValue();
	bool SetMaxVitalValue(float NewMaxValue, ETngVitalChangedReason Reason);
	void SetVitalAutoRecovery(float NewAutoRecoveryPerSec);
	bool SetVitalValue(float NewValue, ETngVitalChangedReason Reason);
	bool ShouldDeathAtZero();

	struct FGameplayTag GetDamageVitalTag() const;
	float GetMaxVitalValue() const;
	float GetVitalRate() const;
	struct FGameplayTag GetVitalTag() const;
	float GetVitalValue() const;
	bool IsProtection() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngVitalElementBase">();
	}
	static class UTngVitalElementBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngVitalElementBase>();
	}
};
static_assert(alignof(UTngVitalElementBase) == 0x000008, "Wrong alignment on UTngVitalElementBase");
static_assert(sizeof(UTngVitalElementBase) == 0x000058, "Wrong size on UTngVitalElementBase");
static_assert(offsetof(UTngVitalElementBase, OnChanged) == 0x000028, "Member 'UTngVitalElementBase::OnChanged' has a wrong offset!");
static_assert(offsetof(UTngVitalElementBase, Value) == 0x000038, "Member 'UTngVitalElementBase::Value' has a wrong offset!");
static_assert(offsetof(UTngVitalElementBase, MaxValue) == 0x00003C, "Member 'UTngVitalElementBase::MaxValue' has a wrong offset!");
static_assert(offsetof(UTngVitalElementBase, VitalTag) == 0x000040, "Member 'UTngVitalElementBase::VitalTag' has a wrong offset!");
static_assert(offsetof(UTngVitalElementBase, DamageVitalTag) == 0x000048, "Member 'UTngVitalElementBase::DamageVitalTag' has a wrong offset!");
static_assert(offsetof(UTngVitalElementBase, AutoRecoveryPerSec) == 0x000050, "Member 'UTngVitalElementBase::AutoRecoveryPerSec' has a wrong offset!");

// Class TangoLib.TngWidgetFunction
// 0x0000 (0x0028 - 0x0028)
class UTngWidgetFunction final : public UBlueprintFunctionLibrary
{
public:
	static void DrawWidgetToRenderTarget(class UTextureRenderTarget2D* Target, class UWidget* Widget, const struct FVector2D& Size, bool UseGamma, float DeltaTime, const struct FVector2D& OffsetPos);
	static bool GetAxisPress(class UObject* WorldContextObject, ETngKeyAxisMap Key);
	static bool GetAxisPressed(class UObject* WorldContextObject, ETngKeyAxisMap Key);
	static bool GetAxisRelease(class UObject* WorldContextObject, ETngKeyAxisMap Key);
	static float GetAxisValue(class UObject* WorldContextObject, ETngKeyAxisMap Key);
	static bool GetButtonPress(class UObject* WorldContextObject, ETngKeyButtonMap Key);
	static bool GetButtonPressed(class UObject* WorldContextObject, ETngKeyButtonMap Key);
	static bool GetButtonRelease(class UObject* WorldContextObject, ETngKeyButtonMap Key);
	static bool GetButtonRepeat(class UObject* WorldContextObject, ETngKeyButtonMap Key);
	static class UWidget* GetFocusWidgetInAllChildren(class UWidget* CheckWidget);
	static TArray<ETngKeyAxisMap> GetKeyAxis(class UObject* WorldContextObject, const struct FKey& TargetKey);
	static TArray<ETngKeyButtonMap> GetKeyButtons(class UObject* WorldContextObject, const struct FKey& TargetKey);
	static TArray<ETngKeyButtonMap> GetKeyMouseDownButtons(class UObject* WorldContextObject, const struct FPointerEvent& InMouseEvent);
	static TArray<ETngKeyButtonMap> GetKeyMouseUpButtons(class UObject* WorldContextObject, const struct FPointerEvent& InMouseEvent);
	static struct FVector2D GetLastMousePosition(class UObject* WorldContextObject);
	static bool GetPlayerInputPress(const class APlayerController* PlayerController, class FName PlayerInputName);
	static float GetWheelDelta(class UObject* WorldContextObject);
	static bool HasAnyButtonState(ETngKeyState State, int32 Condition);
	static bool IsDownStickButton(class UObject* WorldContextObject, ETngKeyButtonMap Key, float AxisDeadZone);
	static bool IsUseGamepad(class UObject* WorldContextObject);
	static void K2_GetGenericReactButtonDirection(ETngKeyButtonMap Key, ETngKeyState ButtonState, ETngButtonDirection* Direction);
	static void LayoutChildInvalidate(class UWidget* Widget, bool IsInChild);
	static void PlayTngAnimation(class UUserWidget* Target, class UWidgetAnimation* InAnimation, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed);
	static void ViewportInvalidate();

	int32 GetCurrentViewMode(const class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngWidgetFunction">();
	}
	static class UTngWidgetFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngWidgetFunction>();
	}
};
static_assert(alignof(UTngWidgetFunction) == 0x000008, "Wrong alignment on UTngWidgetFunction");
static_assert(sizeof(UTngWidgetFunction) == 0x000028, "Wrong size on UTngWidgetFunction");

// Class TangoLib.TngWidgetInputSettings
// 0x0020 (0x0048 - 0x0028)
class UTngWidgetInputSettings final : public UObject
{
public:
	TArray<struct FTngWidgetKeyButtonMapping>     KeyButtonMappings;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FTngWidgetKeyAxisMapping>       KeyAxisMappings;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TngWidgetInputSettings">();
	}
	static class UTngWidgetInputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTngWidgetInputSettings>();
	}
};
static_assert(alignof(UTngWidgetInputSettings) == 0x000008, "Wrong alignment on UTngWidgetInputSettings");
static_assert(sizeof(UTngWidgetInputSettings) == 0x000048, "Wrong size on UTngWidgetInputSettings");
static_assert(offsetof(UTngWidgetInputSettings, KeyButtonMappings) == 0x000028, "Member 'UTngWidgetInputSettings::KeyButtonMappings' has a wrong offset!");
static_assert(offsetof(UTngWidgetInputSettings, KeyAxisMappings) == 0x000038, "Member 'UTngWidgetInputSettings::KeyAxisMappings' has a wrong offset!");

}

